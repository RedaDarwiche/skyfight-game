<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PowerSwap.io</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    
    <style>
        :root {
            --primary: #00f2fe;
            --secondary: #4facfe;
            --accent: #ff0055;
            --dark: #0f172a;
            --surface: rgba(15, 23, 42, 0.85);
            --glass-border: rgba(255, 255, 255, 0.15);
            --success: #10b981;
            --warning: #f59e0b;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-font-smoothing: antialiased; }
        
        body {
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            background-color: var(--dark);
            color: white;
            height: 100vh;
            width: 100vw;
        }

        #gameCanvas { position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; inset: 0; z-index: 10; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }

        .glass-panel {
            background: var(--surface);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            color: white;
        }

        .btn-neon {
            background: linear-gradient(135deg, var(--secondary), var(--primary));
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            color: #0f172a;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.3);
        }
        .btn-neon:hover { filter: brightness(1.2); transform: translateY(-2px); }
        .btn-neon:active { transform: translateY(0); }
        .btn-neon:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .btn-text {
            background: transparent; 
            border: 1px solid rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.8);
            cursor: pointer; 
            font-weight: 700; 
            font-size: 0.9rem; 
            margin-top: 12px;
            padding: 12px 24px;
            border-radius: 8px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
        }
        .btn-text:hover { 
            color: white; 
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.5);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }

        input.modern-input, textarea.modern-input, select.modern-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--glass-border);
            padding: 12px;
            border-radius: 8px;
            color: white;
            font-family: inherit;
            margin-bottom: 12px;
            outline: none;
            transition: border-color 0.2s;
        }
        input.modern-input:focus, select.modern-input:focus, textarea.modern-input:focus { border-color: var(--primary); }

        #top-left-ui { position: absolute; top: 20px; left: 20px; z-index: 2000; display: flex; flex-direction: column; align-items: flex-start; gap: 10px; }
        #top-right-ui { position: absolute; top: 20px; right: 20px; z-index: 2000; display: flex; gap: 10px; }

        #user-profile {
            display: flex; align-items: center; gap: 10px;
            background: rgba(0,0,0,0.8); padding: 8px 20px; border-radius: 50px;
            border: 1px solid var(--glass-border);
        }

        #main-menu {
            position: absolute; inset: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, rgba(15, 23, 42, 0.95), #020617);
            z-index: 100;
        }

        h1.logo {
            font-size: 5rem; font-weight: 900;
            background: linear-gradient(to right, #00f2fe, #4facfe);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
        }

        .menu-card { width: 100%; max-width: 400px; text-align: center; }

        #hud-bottom {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: none; flex-direction: column; align-items: center; gap: 10px; z-index: 50;
        }

        .power-slot {
            width: 80px; height: 80px;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            display: flex; justify-content: center; align-items: center;
            position: relative; transition: all 0.3s;
        }
        .power-slot.active {
            border-color: var(--primary);
            box-shadow: 0 0 30px rgba(0, 242, 254, 0.4);
            background: rgba(0, 242, 254, 0.1);
        }
        .power-slot.omega-active {
            animation: omegaPulse 0.5s infinite;
            border-color: #ffd700;
        }
        .power-slot.speed-active {
            animation: speedPulse 0.5s infinite;
        }
        @keyframes speedPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(239, 68, 68, 0.6); }
            50% { box-shadow: 0 0 50px rgba(239, 68, 68, 1); }
        }
        @keyframes omegaPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
            50% { box-shadow: 0 0 50px rgba(255, 0, 128, 1); }
        }
        .key-hint {
            position: absolute; bottom: -45px; width: 200px; text-align: center;
            font-size: 0.8rem; font-weight: bold; opacity: 0.8;
            display: flex; flex-direction: column; gap: 2px;
        }

        #kill-counter {
            position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
            display: none; z-index: 50;
            background: rgba(0,0,0,0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #kill-counter.close-to-omega {
            animation: killCounterPulse 1s infinite;
            border-color: #ffd700;
        }
        @keyframes killCounterPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 1); }
        }

        #leaderboard {
            position: absolute; top: 70px; right: 20px;
            width: 200px; display: none; z-index: 50;
        }
        .lb-header {
            font-size: 1rem; font-weight: 800; color: var(--primary);
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 8px; margin-bottom: 8px;
            display: flex; justify-content: space-between;
        }
        .lb-row {
            display: flex; justify-content: space-between;
            padding: 5px 0; font-size: 0.9rem; color: rgba(255,255,255,0.8);
        }
        .lb-row.me { color: white; font-weight: bold; text-shadow: 0 0 10px var(--primary); }

        #chat-wrap {
            position: absolute; bottom: 20px; left: 20px; width: 350px; display: none; z-index: 50;
        }
        #chat-history {
            height: 200px; overflow-y: auto;
            mask-image: linear-gradient(to bottom, transparent, black 10%);
            margin-bottom: 10px; display: flex; flex-direction: column; justify-content: flex-end;
        }
        .chat-msg { margin-bottom: 5px; font-size: 0.9rem; }

        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8);
            backdrop-filter: blur(8px); z-index: 3000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-content {
            width: 90%; max-width: 450px; position: relative;
            animation: slideUp 0.3s ease-out;
            max-height: 90vh; overflow-y: auto;
        }
        @keyframes slideUp { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        .close-btn {
            position: absolute; top: 15px; right: 20px;
            font-size: 1.5rem; cursor: pointer; color: rgba(255,255,255,0.5);
        }
        .close-btn:hover { color: white; }

        #forum-posts { 
            max-height: 420px; 
            overflow-y: auto; 
            margin-top: 16px;
            padding-right: 4px;
            scroll-behavior: smooth;
        }
        #forum-posts::-webkit-scrollbar { width: 4px; }
        #forum-posts::-webkit-scrollbar-track { background: transparent; }
        #forum-posts::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
        #forum-posts::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }
        .modal-content::-webkit-scrollbar { width: 4px; }
        .modal-content::-webkit-scrollbar-track { background: transparent; }
        .modal-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
        .forum-post {
            background: rgba(15, 23, 42, 0.6);
            padding: 18px;
            border-radius: 10px;
            margin-bottom: 10px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.08);
            transition: border-color 0.2s, background 0.2s;
        }
        .forum-post:hover {
            border-color: rgba(255,255,255,0.18);
            background: rgba(15, 23, 42, 0.8);
        }
        .forum-post h4 { 
            color: white; 
            margin-bottom: 6px; 
            font-size: 1rem;
            font-weight: 700;
        }
        .forum-post .meta { 
            font-size: 0.72rem; 
            color: rgba(255,255,255,0.4);
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .forum-post .post-content { 
            margin-top: 10px; 
            margin-bottom: 12px;
            line-height: 1.6;
            color: rgba(255,255,255,0.8);
            font-size: 0.92rem;
        }
        .forum-post .delete-btn {
            position: absolute; top: 14px; right: 14px;
            background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239,68,68,0.4);
            color: #ef4444; padding: 4px 10px; border-radius: 5px;
            cursor: pointer; font-size: 0.68rem; font-weight: 700;
            transition: all 0.2s;
        }
        .forum-post .delete-btn:hover { background: rgba(239,68,68,0.3); border-color: #ef4444; }

        .comments-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.07);
        }
        .comments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .comments-header span {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.45);
            font-weight: 500;
        }
        .toggle-comments {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 5px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .toggle-comments:hover { 
            border-color: rgba(255,255,255,0.35);
            color: white;
        }
        .comments-list {
            display: none;
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 10px;
            scroll-behavior: smooth;
        }
        .comments-list::-webkit-scrollbar { width: 3px; }
        .comments-list::-webkit-scrollbar-track { background: transparent; }
        .comments-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 3px; }
        .comments-list.visible { display: block; }
        .comment {
            background: rgba(255,255,255,0.04);
            padding: 10px 12px;
            border-radius: 7px;
            margin-bottom: 6px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.06);
            transition: background 0.15s;
        }
        .comment:hover {
            background: rgba(255,255,255,0.07);
        }
        .comment.reply {
            margin-left: 24px;
            border-left: 2px solid rgba(255,255,255,0.1);
            border-radius: 0 7px 7px 0;
        }
        .comment .comment-author {
            font-weight: 700;
            color: rgba(255,255,255,0.85);
            font-size: 0.8rem;
        }
        .comment .comment-text {
            font-size: 0.88rem;
            margin-top: 4px;
            line-height: 1.5;
            color: rgba(255,255,255,0.7);
        }
        .comment .comment-date {
            font-size: 0.67rem;
            color: rgba(255,255,255,0.3);
            margin-top: 5px;
        }
        .comment .comment-actions {
            display: flex;
            gap: 6px;
            margin-top: 7px;
        }
        .comment .reply-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.5);
            padding: 3px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.67rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        .comment .reply-btn:hover { 
            border-color: rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.85);
        }
        .comment .delete-comment-btn {
            background: transparent;
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: rgba(239,68,68,0.7);
            padding: 3px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.67rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        .comment .delete-comment-btn:hover { background: rgba(239,68,68,0.15); color: #ef4444; }
        .reply-form {
            display: none;
            margin-top: 8px;
            margin-left: 30px;
        }
        .reply-form.visible { 
            display: flex; 
            gap: 8px; 
            animation: slideDown 0.3s ease-out;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .reply-form input {
            flex: 1;
            margin-bottom: 0;
        }
        .reply-form button {
            padding: 8px 16px;
            font-size: 0.75rem;
        }
        .add-comment-form {
            display: none;
            margin-top: 12px;
        }
        .add-comment-form.visible { 
            display: flex; 
            gap: 10px;
        }
        .add-comment-form input {
            flex: 1;
            margin-bottom: 0;
        }
        .add-comment-form button {
            padding: 10px 16px;
            font-size: 0.8rem;
            font-weight: 700;
        }

        .login-required-msg {
            text-align: center;
            padding: 20px;
            color: rgba(255,255,255,0.6);
            font-style: italic;
        }
        .login-required-msg a {
            color: var(--primary);
            cursor: pointer;
        }

        #toast-container {
            position: absolute;
            top: 80px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 12px; pointer-events: none; z-index: 4000;
            align-items: center;
        }
        
        .toast {
            display: flex; align-items: center; gap: 12px;
            padding: 14px 24px; border-radius: 50px;
            font-weight: 700; font-size: 0.95rem;
            animation: toastIn 0.4s ease-out;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        
        .toast.success { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        .toast.error { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        .toast.info { background: linear-gradient(135deg, #00f2fe, #4facfe); color: #0f172a; }
        .toast.warning { background: linear-gradient(135deg, #f59e0b, #d97706); color: #0f172a; }
        .toast.power { background: linear-gradient(135deg, #a855f7, #8b5cf6); color: white; }
        .toast.omega { background: linear-gradient(135deg, #ffd700, #ff6b00); color: white; }
        .toast.admin { background: linear-gradient(135deg, #ff00ff, #00ffff); color: white; }
        .toast.kill { background: linear-gradient(135deg, #dc2626, #991b1b); color: white; }
        .toast.mythic { background: linear-gradient(135deg, #ff00cc, #3333ff); color: white; }
        #baby-controls {
            position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%);
            z-index: 6000; display: none;
            background: rgba(0,0,0,0.9); border: 2px solid #ff69b4;
            border-radius: 16px; padding: 14px 20px; text-align: center;
            box-shadow: 0 0 30px rgba(255,105,180,0.5);
        }
        #baby-controls.visible { display: block; }
        #baby-controls h4 { color: #ff69b4; font-size: 0.9rem; margin-bottom: 10px; letter-spacing: 1px; }
        .baby-hp-bar { width: 200px; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; margin: 0 auto 10px; }
        .baby-hp-fill { height: 100%; background: linear-gradient(90deg, #ff69b4, #ff1493); border-radius: 3px; transition: width 0.3s; }
        .baby-btn-row { display: flex; gap: 8px; justify-content: center; }
        .baby-btn { padding: 7px 14px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 0.8rem; border: none; transition: all 0.2s; }
        .baby-btn.destruct { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        .baby-btn.recall { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        .baby-btn:hover { filter: brightness(1.2); transform: translateY(-1px); }
        
        .toast-exit { animation: toastOut 0.3s ease-in forwards; }
        @keyframes toastIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes toastOut { to { opacity: 0; transform: translateY(-10px); } }

        #damage-numbers { position: absolute; inset: 0; pointer-events: none; z-index: 100; }
        .dmg-num {
            position: absolute; font-weight: 900; font-size: 24px;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            animation: floatUp 1s ease-out forwards; pointer-events: none;
        }
        .dmg-num.damage { color: #ef4444; }
        .dmg-num.heal { color: #10b981; }
        .dmg-num.crit { color: #f59e0b; font-size: 32px; }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
        }

        .power-type-badge {
            position: absolute; top: -8px; right: -8px;
            background: rgba(0,0,0,0.8); padding: 2px 8px; border-radius: 10px;
            font-size: 0.65rem; text-transform: uppercase; font-weight: bold;
        }
        .power-type-badge.omega { background: linear-gradient(135deg, #ffd700, #ff6b00); }

        #clone-timer {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            width: 150px; height: 8px; background: rgba(0,0,0,0.5);
            border-radius: 4px; overflow: hidden; display: none;
        }
        #clone-timer-fill { height: 100%; background: linear-gradient(90deg, #14b8a6, #10b981); }
        #clone-timer-label {
            position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
            font-size: 0.75rem; color: #14b8a6; font-weight: bold; display: none;
        }

        #death-screen {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            z-index: 5000; display: none; justify-content: center;
            align-items: center; flex-direction: column;
        }
        #death-screen.active { display: flex; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .death-text {
            font-size: 5rem; font-weight: 900; color: #ef4444;
            text-shadow: 0 0 50px rgba(239, 68, 68, 0.5);
        }
        .respawn-timer { margin-top: 30px; font-size: 1.5rem; color: rgba(255,255,255,0.8); }

        #admin-panel {
            position: absolute; top: 70px; left: 20px;
            width: 280px; display: none; z-index: 2500;
            max-height: calc(100vh - 100px); overflow-y: auto;
        }
        #admin-panel.visible { display: block; }
        #admin-panel h3 { color: #ff00ff; margin-bottom: 15px; }
        .admin-section { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .admin-section-title { font-size: 0.8rem; text-transform: uppercase; color: rgba(255,255,255,0.5); margin-bottom: 8px; }
        .admin-btn {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 12px; border-radius: 8px; color: white; cursor: pointer;
            width: 100%; margin-bottom: 6px; transition: all 0.2s;
        }
        .admin-btn:hover { background: rgba(255,255,255,0.2); }
        .admin-btn.active { background: rgba(255,215,0,0.3); border-color: #ffd700; }
        .power-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
        .power-grid-btn {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 4px; border-radius: 8px; color: white; cursor: pointer;
            font-size: 0.7rem; display: flex; flex-direction: column; align-items: center;
        }
        .power-grid-btn:hover { transform: scale(1.05); }
        #admin-toggle {
            position: absolute; top: 20px; left: 20px; z-index: 2600; display: none;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            border: none; padding: 10px 15px; border-radius: 8px;
            color: white; font-weight: bold; cursor: pointer;
        }

        #game-announcement {
            position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
            z-index: 6000; display: none; text-align: center; pointer-events: none;
        }
        #game-announcement.visible { display: block; animation: announceFade 5s forwards; }
        .announce-text {
            font-size: 2rem; font-weight: 900;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: none;
            padding: 10px 30px;
            border: 2px solid rgba(255, 0, 255, 0.5);
            border-radius: 16px;
            background-clip: text;
            backdrop-filter: blur(10px);
            background-color: rgba(0,0,0,0.7);
        }
        @keyframes announceFade {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            15% { opacity: 1; transform: translateX(-50%) translateY(0); }
            70% { opacity: 1; }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }

        #omega-unlock-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            z-index: 5000; display: none; justify-content: center;
            align-items: center; flex-direction: column;
        }
        #omega-unlock-overlay.active { display: flex; animation: omegaFlash 2s forwards; }
        @keyframes omegaFlash {
            0% { background: rgba(255,215,0,0.8); }
            100% { background: rgba(0,0,0,0); }
        }
        .omega-text {
            font-size: 3rem; font-weight: 900;
            background: linear-gradient(135deg, #ffd700, #ff6b00, #ff0080);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .connecting-text { margin-top: 10px; color: rgba(255,255,255,0.6); }
        .connecting-text.active { animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }

        #screen-effects { position: fixed; inset: 0; pointer-events: none; z-index: 90; }
        .timestop-effect {
            position: absolute; inset: 0;
            background: radial-gradient(circle, transparent 30%, rgba(0,255,255,0.2) 100%);
            animation: effectPulse 0.5s infinite;
        }
        .mirror-effect {
            position: absolute; inset: 0;
            background: radial-gradient(circle, transparent 40%, rgba(192,192,192,0.15) 100%);
        }
        @keyframes effectPulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 0.8; } }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="screen-effects"></div>

    <div id="ui-layer">
        <div id="top-left-ui" class="pointer-events-auto">
            <button id="login-btn" class="btn-neon" onclick="openModal('login-modal')">Login / Sign Up</button>
            <div id="user-profile" style="display: none;">
                <div style="display:flex; flex-direction:column;">
                    <span style="font-size:0.8rem; color:rgba(255,255,255,0.6);">Logged in as</span>
                    <span id="profile-name" style="font-weight: bold; color:var(--primary);">User</span>
                </div>
                <button class="btn-text" onclick="signOut()" style="margin:0; margin-left:15px; font-size: 0.8rem; color: #ff0055;">Logout</button>
            </div>
        </div>

        <div id="top-right-ui" class="pointer-events-auto">
            <button class="btn-neon" onclick="openForum()">Forum</button>
        </div>

        <div id="main-menu" class="pointer-events-auto">
            <h1 class="logo">PowerSwap.io</h1>
            <div class="glass-panel menu-card">
                <input type="text" id="username-input" class="modern-input" placeholder="Enter Nickname" maxlength="12" style="text-align: center; font-size: 1.2rem;">
                <button id="play-btn" onclick="joinGame()" class="btn-neon" style="width: 100%; padding: 15px; font-size: 1.2rem;">Play Now</button>
                <div id="connecting-status" class="connecting-text" style="display: none;">Connecting...</div>
            </div>
            <div style="margin-top: 20px; color: rgba(255,255,255,0.5); font-size: 0.9rem;">
                Mouse to Move | SPACE to Use Power | D to Drop
            </div>
            <div style="margin-top: 10px; color: rgba(255,215,0,0.7); font-size: 0.85rem;">
                Get 10 kills to unlock OMEGA powers! Press Q to activate
            </div>
        </div>

        <button id="admin-toggle" class="pointer-events-auto" onclick="toggleAdminPanel()">OWNER</button>

        <div id="admin-panel" class="glass-panel pointer-events-auto">
            <h3>Owner Panel</h3>
            <div class="admin-section">
                <div class="admin-section-title">Quick Actions</div>
                <button class="admin-btn" onclick="adminAction('heal')">Full Heal Self</button>
                <button class="admin-btn" onclick="adminAction('kill_all')">Kill All Players</button>
                <button class="admin-btn" onclick="adminAction('teleport_center')">Teleport Center</button>
                <button class="admin-btn" onclick="adminAction('add_kills')">+10 Kills</button>
                <button class="admin-btn" onclick="adminAction('heal_all')">Heal All Players</button>
                <button class="admin-btn" onclick="adminAction('clear_powerups')">Clear All Powerups</button>
                <button class="admin-btn" onclick="adminAction('respawn_all')">Respawn All</button>
                <button class="admin-btn" onclick="adminSpawnBoss()" style="background:rgba(220,38,38,0.3);border-color:#dc2626;">‚ö†Ô∏è Force Spawn Boss</button>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">Toggles</div>
                <button class="admin-btn" id="godmode-btn" onclick="adminAction('toggle_godmode')">God Mode: OFF</button>
                <button class="admin-btn" id="infinite-btn" onclick="adminAction('toggle_infinite')">Infinite Power: OFF</button>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">UNRELEASED ADMIN POWERS</div>
                <div class="power-grid" id="admin-omega-grid"></div>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">All Regular Powers</div>
                <div class="power-grid" id="admin-powers-grid"></div>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">üì¢ Announce In-Game</div>
                <textarea id="announce-text" class="modern-input" placeholder="Type announcement..." style="height: 60px; resize: none;"></textarea>
                <button class="admin-btn" style="background: rgba(255,0,255,0.2); border-color: #ff00ff;" onclick="sendAnnouncement()">üì¢ Broadcast to All</button>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">Spawn Powerup</div>
                <select id="spawn-power-select" class="modern-input"></select>
                <button class="admin-btn" onclick="adminAction('spawn_power')">Spawn at Cursor</button>
            </div>
        </div>

        <div id="hud-bottom">
            <div class="power-slot glass-panel" id="power-slot">
                <canvas id="power-icon-canvas" width="50" height="50"></canvas>
                <span class="power-type-badge" id="power-type-badge" style="display:none;"></span>
                <div class="key-hint">
                    <span id="power-hint-text">No Power</span>
                    <span style="font-size: 0.7rem; opacity: 0.6;">D to Drop</span>
                </div>
            </div>
        </div>

        <div id="kill-counter">
            <span>Kills: <span id="kill-count">0</span>/<span id="kill-threshold">10</span></span>
            <span id="omega-ready" style="display:none; color: #ffd700; margin-left: 10px;"></span>
        </div>

        <div id="clone-timer-label">CLONE ACTIVE</div>
        <div id="clone-timer"><div id="clone-timer-fill"></div></div>

        <div id="leaderboard" class="glass-panel">
            <div class="lb-header">
                <span>Leaderboard</span>
                <span style="font-size:0.7rem; opacity:0.7;">Kills</span>
            </div>
            <div id="lb-content"><div class="lb-row"><span>Loading...</span></div></div>
        </div>

        <div id="chat-wrap" class="pointer-events-auto">
            <div id="chat-history"></div>
            <input type="text" id="chat-input" class="modern-input" placeholder="Type to chat..." maxlength="80" style="margin-bottom: 0;">
        </div>

        <div id="damage-numbers"></div>
    </div>

    <div id="game-announcement">
        <div class="announce-text" id="announce-message"></div>
    </div>

    <div id="death-screen">
        <div class="death-text">WASTED</div>
        <div class="respawn-timer">Respawning in <span id="respawn-countdown">3</span>...</div>
    </div>

    <div id="omega-unlock-overlay">
        <div class="omega-text">OMEGA UNLOCKED</div>
        <div id="omega-power-name" style="color: #ffd700; margin-top: 20px; font-size: 1.5rem; font-weight: bold;"></div>
        <div style="color: rgba(255,255,255,0.8); margin-top: 10px;">Press Q to activate!</div>
    </div>

    <div id="login-modal" class="modal-overlay pointer-events-auto">
        <div class="glass-panel modal-content">
            <span class="close-btn" onclick="closeModal('login-modal')">√ó</span>
            <h2 style="margin-bottom: 20px; text-align: center;">Welcome Back</h2>
            <input type="email" id="auth-email" class="modern-input" placeholder="Email Address">
            <input type="password" id="auth-pass" class="modern-input" placeholder="Password">
            <button class="btn-neon" style="width: 100%;" onclick="handleLogin()">Login</button>
            <button class="btn-text" style="width: 100%;" onclick="openModal('signup-modal'); closeModal('login-modal')">Create New Account</button>
        </div>
    </div>

    <div id="signup-modal" class="modal-overlay pointer-events-auto">
        <div class="glass-panel modal-content">
            <span class="close-btn" onclick="closeModal('signup-modal')">√ó</span>
            <h2 style="margin-bottom: 20px; text-align: center;">Create Account</h2>
            <input type="text" id="signup-username" class="modern-input" placeholder="Username" maxlength="15">
            <input type="email" id="signup-email" class="modern-input" placeholder="Email Address">
            <input type="password" id="signup-pass" class="modern-input" placeholder="Password (6+ chars)">
            <button class="btn-neon" style="width: 100%;" onclick="handleSignup()">Sign Up</button>
            <button class="btn-text" style="width: 100%;" onclick="openModal('login-modal'); closeModal('signup-modal')">Back to Login</button>
        </div>
    </div>

    <div id="forum-modal" class="modal-overlay pointer-events-auto">
        <div class="glass-panel modal-content" style="max-width: 600px;">
            <span class="close-btn" onclick="closeModal('forum-modal')">√ó</span>
            <h2 style="margin-bottom: 15px;">Community Forum</h2>
            
            <div id="forum-create-ui" style="border-bottom: 1px solid var(--glass-border); padding-bottom: 15px; display: none;">
                <input type="text" id="forum-title" class="modern-input" placeholder="Title">
                <textarea id="forum-desc" class="modern-input" placeholder="Message..." style="height: 80px;"></textarea>
                <button class="btn-neon" onclick="createPost()">Post Message</button>
            </div>
            
            <div id="forum-login-required" class="login-required-msg">
                <p>Please <a onclick="closeModal('forum-modal'); openModal('login-modal')">login</a> or <a onclick="closeModal('forum-modal'); openModal('signup-modal')">sign up</a> to create posts and comments.</p>
            </div>
            
            <div id="forum-posts"></div>
        </div>
    </div>
    <div id="baby-controls" class="pointer-events-auto">
        <h4>üçº BABY CONTROLS</h4>
        <div style="font-size:0.75rem; color:rgba(255,255,255,0.6); margin-bottom:8px;">Baby moves toward your mouse. HP: <span id="baby-hp-text">50</span>/50</div>
        <div class="baby-hp-bar"><div class="baby-hp-fill" id="baby-hp-fill" style="width:100%"></div></div>
        <div class="baby-btn-row">
            <button class="baby-btn recall" onclick="recallBaby()">‚Ü© Return</button>
            <button class="baby-btn destruct" onclick="destructBaby()">üí• Self-Destruct</button>
        </div>
    </div>
            <div id="toast-container"></div>

    <script>
        const CONFIG = {
            colors: { primary: '#00f2fe', grid: '#1e293b', gridLine: '#334155' },
            map: { width: 4000, height: 4000 },
            serverUrl: 'https://skyfight-server.onrender.com',
            adminEmail: 'redadarwichepaypal@gmail.com',
            killsForOmega: 10
        };

        const POWERS = {
            dash: { color: '#f59e0b', name: 'Dash', type: 'instant', rarity: 'common' },
            teleport: { color: '#10b981', name: 'Warp', type: 'instant', rarity: 'rare' },
            clone: { color: '#14b8a6', name: 'Clone', type: 'instant', rarity: 'epic' },
            blackhole: { color: '#1e1b4b', name: 'Blackhole', type: 'instant', rarity: 'legendary' },
            nuke: { color: '#dc2626', name: 'Nuke', type: 'instant', rarity: 'legendary' },
            heal: { color: '#22c55e', name: 'Heal', type: 'instant', rarity: 'common' },
            emp: { color: '#6366f1', name: 'EMP', type: 'instant', rarity: 'rare' },
            swap: { color: '#ec4899', name: 'Swap', type: 'instant', rarity: 'epic' },
            shockwave: { color: '#8b5cf6', name: 'Shockwave', type: 'instant', rarity: 'rare' },
            speed: { color: '#ef4444', name: 'Speed', type: 'toggle', rarity: 'common' },
            phase: { color: '#a78bfa', name: 'Phase', type: 'toggle', rarity: 'epic' },
            berserker: { color: '#dc2626', name: 'Berserker', type: 'toggle', rarity: 'rare' },
            shield: { color: '#3b82f6', name: 'Shield', type: 'passive', rarity: 'common' },
            vampire: { color: '#7f1d1d', name: 'Vampire', type: 'passive', rarity: 'epic' },
            rage: { color: '#b91c1c', name: 'Rage', type: 'passive', rarity: 'rare' },
            tank: { color: '#374151', name: 'Tank', type: 'passive', rarity: 'rare' },
            magnet: { color: '#f97316', name: 'Magnet', type: 'passive', rarity: 'common' },
            thorns: { color: '#65a30d', name: 'Thorns', type: 'passive', rarity: 'rare' },
            regeneration: { color: '#34d399', name: 'Regen', type: 'passive', rarity: 'rare' },
            tripleshot: { color: '#a855f7', name: 'Triple', type: 'shoot', rarity: 'common' },
            laser: { color: '#ef4444', name: 'Laser', type: 'instant', rarity: 'rare' },
            rocket: { color: '#fb923c', name: 'Rocket', type: 'instant', rarity: 'epic' },
            scatter: { color: '#fbbf24', name: 'Scatter', type: 'shoot', rarity: 'rare' },
            sniper: { color: '#0ea5e9', name: 'Sniper', type: 'shoot', rarity: 'epic' },
            minigun: { color: '#78716c', name: 'Minigun', type: 'shoot', rarity: 'rare' },
            explosive: { color: '#f87171', name: 'Explosive', type: 'shoot', rarity: 'epic' },
            freeze: { color: '#0ea5e9', name: 'Freeze', type: 'shoot', rarity: 'rare' },
            poison: { color: '#84cc16', name: 'Poison', type: 'instant', rarity: 'rare' },
            lightning: { color: '#facc15', name: 'Lightning', type: 'instant', rarity: 'epic' },
            // COOL POWERS
            timebomb: { color: '#ff6b00', name: 'Time Bomb', type: 'instant', rarity: 'epic' },
            orbitallaser: { color: '#00f5ff', name: 'Orbital Laser', type: 'instant', rarity: 'legendary' },
            shadowclone: { color: '#1a1a2e', name: 'Shadow Clone', type: 'instant', rarity: 'epic' },
            frostnova: { color: '#a5f3fc', name: 'Frost Nova', type: 'instant', rarity: 'legendary' },
            soulrip: { color: '#7c00ff', name: 'Soul Rip', type: 'instant', rarity: 'legendary' },
            voidbeam: { color: '#5b21b6', name: 'Void Beam', type: 'shoot', rarity: 'legendary' },
            // FUNCTIONAL POWERS
            gravitypull: { color: '#7c3aed', name: 'Gravity Pull', type: 'instant', rarity: 'epic' },
            mirror: { color: '#c0c0c0', name: 'Mirror Shield', type: 'instant', rarity: 'epic' },
            chaos: { color: '#ec4899', name: 'Chaos Orb', type: 'instant', rarity: 'legendary' },
            baby: { color: '#ff69b4', name: 'Baby', type: 'instant', rarity: 'mythic' },
            phoenix: { color: '#ff6600', name: 'Phoenix', type: 'passive', rarity: 'mythic' },
            soulsteal: { color: '#8800ff', name: 'Soul Steal', type: 'instant', rarity: 'mythic' }
        };

        // Single Omega power - first to 10 kills gets this
        const OMEGA_POWER = {
            meteor: { color: '#ff4500', name: 'METEOR STRIKE', type: 'omega', rarity: 'omega' }
        };

        // Admin-only unreleased powers - ACTUALLY INSANE
        const ADMIN_POWERS = {
            apocalypse: { color: '#ff0000', name: 'APOCALYPSE', type: 'admin', rarity: 'admin' },
            chronobreak: { color: '#00ffff', name: 'CHRONO BREAK', type: 'admin', rarity: 'admin' },
            voidrift: { color: '#9333ea', name: 'VOID RIFT', type: 'admin', rarity: 'admin' },
            armageddon: { color: '#fbbf24', name: 'ARMAGEDDON', type: 'admin', rarity: 'admin' },
            omegabeam: { color: '#06b6d4', name: 'OMEGA BEAM', type: 'admin', rarity: 'admin' },
            singularity: { color: '#a855f7', name: 'SINGULARITY', type: 'admin', rarity: 'admin' },
            realitybomb: { color: '#ec4899', name: 'REALITY BOMB', type: 'admin', rarity: 'admin' },
            godmode: { color: '#ffd700', name: 'GOD MODE', type: 'admin', rarity: 'admin' },
            obliterate: { color: '#dc2626', name: 'OBLITERATE', type: 'admin', rarity: 'admin' },
            dimensionrift: { color: '#8b00ff', name: 'DIMENSION RIFT', type: 'admin', rarity: 'admin' },
            cosmicstorm: { color: '#ff1493', name: 'COSMIC STORM', type: 'admin', rarity: 'admin' },
            infinityvoid: { color: '#000066', name: 'INFINITY VOID', type: 'admin', rarity: 'admin' },
            starforge: { color: '#ffdf00', name: 'STAR FORGE', type: 'admin', rarity: 'admin' },
            quantumcollapse: { color: '#00fff7', name: 'QUANTUM COLLAPSE', type: 'admin', rarity: 'admin' },
            worldender: { color: '#b91c1c', name: 'WORLD ENDER', type: 'admin', rarity: 'admin' },
            divinebeam: { color: '#f0abfc', name: 'DIVINE BEAM', type: 'admin', rarity: 'admin' },
            blacksun: { color: '#1c1c1c', name: 'BLACK SUN', type: 'admin', rarity: 'admin' },
            stormcall: { color: '#60a5fa', name: 'STORM CALL', type: 'admin', rarity: 'admin' }
        };

        const RARITY_COLORS = { common: '#9ca3af', rare: '#3b82f6', epic: '#a855f7', legendary: '#f59e0b', omega: '#ffd700', admin: '#ff00ff', mythic: '#ff00cc' };
        const ALL_POWERS = { ...POWERS, ...OMEGA_POWER, ...ADMIN_POWERS };

        let sbClient = null, currentUser = null, dbUsername = '', isAdmin = false;
        let socket = null, myId = null, isConnecting = false, connectionAttempts = 0;
        let powerupIdCounter = 10000, projectileIdCounter = 50000;

        const state = {
            me: null, players: {}, projectiles: {}, powerups: {}, particles: [], clones: [],
            explosions: [], meteors: [], remoteClones: {}, camera: { x: 0, y: 0 },
            mouse: { x: 0, y: 0, worldX: 0, worldY: 0 }, running: false, lastTime: 0,
            speedActive: false, phaseActive: false, berserkerActive: false, shootCooldown: 0,
            cloneTimer: 0, cloneMaxTime: 12, kills: 0, omegaUnlocked: false, omegaPower: null,
            omegaTimer: 0, adminGodMode: false, adminInfinite: false,
            mirrorActive: false, timestopActive: false, hitCooldowns: {}, isDead: false, respawnTimer: 0,
            nextOmegaThreshold: 10,
            baby: null, babyShootCooldown: 0, remoteBabies: {}, babyBroadcastTimer: 0,
            laserBeams: [], rocketTrails: [], timebombs: [],
            bosses: {} // multi-boss NPC state
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const SUPABASE_URL = 'https://jppfsqkshcmwskcdsqis.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpwcGZzcWtzaGNtd3NrY2RzcWlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA5MjczMzgsImV4cCI6MjA4NjUwMzMzOH0.ACkiOnXuKGnzKTqi2HSLggktIzrRWOFLje-dp20dpqU';

        function initSupabase() {
            if (typeof window.supabase !== 'undefined') {
                sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                checkSession();
            }
            initAdminPanel();
        }

        async function checkSession() {
            if (!sbClient) return;
            try {
                const { data } = await sbClient.auth.getSession();
                if (data.session) {
                    currentUser = data.session.user;
                    await fetchProfile();
                    checkAdminStatus();
                }
            } catch(e) { console.error('Session error:', e); }
            updateAuthUI();
            updateForumUI();
        }

       async function fetchProfile() {
            if (!currentUser || !sbClient) return;
            try {
                // 1. Try fetching from the profiles table
                const { data, error } = await sbClient
                    .from('profiles')
                    .select('username')
                    .eq('id', currentUser.id)
                    .single();
                
                // 2. Priority: Use Database name, fallback to Auth Metadata
                if (data && data.username) {
                    dbUsername = data.username;
                } else if (currentUser.user_metadata && currentUser.user_metadata.username) {
                    dbUsername = currentUser.user_metadata.username;
                }
            } catch(e) { 
                console.error('Profile fetch error:', e); 
            }
            // Update the UI immediately after fetching
            updateAuthUI();
        }

        function checkAdminStatus() {
            isAdmin = currentUser && currentUser.email === CONFIG.adminEmail;
            const toggle = document.getElementById('admin-toggle');
            if(toggle) toggle.style.display = isAdmin ? 'block' : 'none';
        }

        function updateAuthUI() {
            if (currentUser) {
                document.getElementById('login-btn').style.display = 'none';
                document.getElementById('user-profile').style.display = 'flex';
                
                // Use dbUsername, fallback to metadata, fallback to 'Player'
                const displayName = dbUsername || (currentUser.user_metadata ? currentUser.user_metadata.username : '') || 'Player';
                
                document.getElementById('profile-name').textContent = displayName;
                document.getElementById('username-input').value = displayName;
            } else {
                document.getElementById('login-btn').style.display = 'block';
                document.getElementById('user-profile').style.display = 'none';
            }
        }

        function updateForumUI() {
            const createUI = document.getElementById('forum-create-ui');
            const loginRequired = document.getElementById('forum-login-required');
            if (currentUser) {
                createUI.style.display = 'block';
                loginRequired.style.display = 'none';
            } else {
                createUI.style.display = 'none';
                loginRequired.style.display = 'block';
            }
        }

        async function handleLogin() {
            if (!sbClient) return;
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-pass').value;
            
            const { data, error } = await sbClient.auth.signInWithPassword({ email, password });
            
            if (error) return showToast(error.message, 'error');
            
            currentUser = data.user;
            showToast('Logged In!', 'success');
            closeModal('login-modal');
            
            // Wait for profile fetch before continuing
            await fetchProfile();
            checkSession();
        }

       async function handleSignup() {
            if (!sbClient) return;
            const email = document.getElementById('signup-email').value.trim();
            const password = document.getElementById('signup-pass').value;
            const username = document.getElementById('signup-username').value.trim();
            
            if (!username) return showToast('Username required', 'error');
            if (username.length < 3) return showToast('Username too short (3+ chars)', 'error');
            if (username.length > 15) return showToast('Username too long (max 15 chars)', 'error');
            if (!/^[a-zA-Z0-9_]+$/.test(username)) return showToast('Username can only contain letters, numbers, and underscores', 'error');

            // 1. CHECK IF USERNAME EXISTS FIRST (case-insensitive)
            try {
                const { data: existingUser, error: checkError } = await sbClient
                    .from('profiles')
                    .select('username')
                    .ilike('username', username) // Case-insensitive match
                    .maybeSingle();

                if (existingUser) {
                    return showToast('Username already taken!', 'error');
                }
            } catch (checkError) {
                console.error('Username check failed:', checkError);
                // Continue anyway - the database unique constraint is the final guard
            }

            // 2. PROCEED WITH SIGNUP
            const { data, error } = await sbClient.auth.signUp({ 
                email, 
                password,
                options: {
                    data: { username: username }
                }
            });

            if (error) {
                // Handle specific signup errors
                if (error.message.includes('already registered')) {
                    return showToast('Email already registered!', 'error');
                }
                return showToast(error.message, 'error');
            }

            if (data.user) {
                // 3. CREATE PROFILE
                const { error: profileError } = await sbClient
                    .from('profiles')
                    .insert([{ id: data.user.id, username }]);

                if (profileError) {
                    console.error('Profile creation error:', profileError);
                    if (profileError.code === '23505') {
                        // Unique constraint violation - username was taken in a race condition
                        return showToast('Username already taken! Please try another.', 'error');
                    }
                    return showToast('Error creating profile. Please try again.', 'error');
                }

                // Success
                currentUser = data.user;
                dbUsername = username;
                updateAuthUI();
                updateForumUI();
                closeModal('signup-modal');
                showToast('Account Created!', 'success');
            }
        }

        async function signOut() {
            if (!sbClient) return;
            await sbClient.auth.signOut();
            currentUser = null; 
            dbUsername = ''; 
            isAdmin = false;
            
            updateAuthUI();
            updateForumUI();
            
            const adminToggle = document.getElementById('admin-toggle');
            if (adminToggle) adminToggle.style.display = 'none';
            
            const adminPanel = document.getElementById('admin-panel');
            if (adminPanel) adminPanel.classList.remove('visible');
            
            showToast('Logged out', 'info');
        }

        function openForum() { 
            openModal('forum-modal'); 
            updateForumUI();
            if (sbClient) loadPosts(); 
        }

        async function loadPosts() {
            if (!sbClient) return;
            try {
                const { data, error } = await sbClient.from('forum_posts').select('*').order('created_at', { ascending: false }).limit(30);
                const container = document.getElementById('forum-posts');
                container.innerHTML = '';
                if (error || !data || data.length === 0) {
                    container.innerHTML = '<p style="text-align:center; opacity:0.6;">No posts yet.</p>';
                    return;
                }
                
                for (const post of data) {
                    const commentsCount = await getCommentsCount(post.id);
                    const isOwnPost = currentUser && post.user_id === currentUser.id;
                    const div = document.createElement('div');
                    div.className = 'forum-post';
                    div.id = `post-${post.id}`;
                    div.innerHTML = `
                        <h4>${escapeHtml(post.title)}</h4>
                        <div class="meta">
                            <span>by <strong>${escapeHtml(post.author || 'Unknown')}</strong>${post.is_owner ? ' <span style="background:linear-gradient(135deg,#ffd700,#ff8c00);color:#000;font-size:0.65rem;font-weight:900;padding:2px 6px;border-radius:4px;letter-spacing:0.5px;">OWNER</span>' : ''}</span>
                            <span>‚Ä¢</span>
                            <span>${new Date(post.created_at).toLocaleDateString()}</span>
                            ${isOwnPost ? '<span style="color: rgba(255,255,255,0.5);">‚Ä¢ Your Post</span>' : ''}
                        </div>
                        <p class="post-content">${escapeHtml(post.description)}</p>
                        ${(isAdmin || isOwnPost) ? `<button class="delete-btn" onclick="deletePost('${post.id}')">Delete</button>` : ''}
                        <div class="comments-section">
                            <div class="comments-header">
                                <span>${commentsCount} comment${commentsCount !== 1 ? 's' : ''}</span>
                                <button class="toggle-comments" onclick="toggleComments('${post.id}')">Show Comments</button>
                            </div>
                            <div class="comments-list" id="comments-${post.id}"></div>
                            ${currentUser ? `
                                <div class="add-comment-form" id="comment-form-${post.id}">
                                    <input type="text" class="modern-input" id="comment-input-${post.id}" placeholder="Write a comment..." maxlength="200">
                                    <button class="btn-secondary" onclick="addComment('${post.id}')">Post</button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    container.appendChild(div);
                }
            } catch(e) {
                document.getElementById('forum-posts').innerHTML = '<p style="text-align:center; opacity:0.6;">Error loading.</p>';
            }
        }

        async function getCommentsCount(postId) {
            if (!sbClient) return 0;
            try {
                const { count } = await sbClient.from('forum_comments').select('*', { count: 'exact', head: true }).eq('post_id', postId);
                return count || 0;
            } catch(e) { return 0; }
        }

        async function toggleComments(postId) {
            const commentsList = document.getElementById(`comments-${postId}`);
            const commentForm = document.getElementById(`comment-form-${postId}`);
            const toggleBtn = commentsList.parentElement.querySelector('.toggle-comments');
            
            if (commentsList.classList.contains('visible')) {
                commentsList.classList.remove('visible');
                if (commentForm) commentForm.classList.remove('visible');
                toggleBtn.textContent = 'Show Comments';
            } else {
                await loadComments(postId);
                commentsList.classList.add('visible');
                if (commentForm) commentForm.classList.add('visible');
                toggleBtn.textContent = 'Hide Comments';
            }
        }

        async function loadComments(postId) {
            if (!sbClient) return;
            const commentsList = document.getElementById(`comments-${postId}`);
            commentsList.innerHTML = '<p style="text-align:center; opacity:0.6; font-size:0.8rem;">Loading...</p>';
            
            try {
                const { data, error } = await sbClient.from('forum_comments').select('*').eq('post_id', postId).order('created_at', { ascending: true });
                
                if (error || !data || data.length === 0) {
                    commentsList.innerHTML = '<p style="text-align:center; opacity:0.6; font-size:0.8rem;">No comments yet.</p>';
                    return;
                }
                
                // Organize comments by parent (for nested replies)
                const topLevelComments = data.filter(c => !c.parent_comment_id);
                const replies = data.filter(c => c.parent_comment_id);
                
                let html = '';
                for (const c of topLevelComments) {
                    html += renderComment(c, postId, false);
                    // Add replies to this comment
                    const commentReplies = replies.filter(r => r.parent_comment_id === c.id);
                    for (const reply of commentReplies) {
                        html += renderComment(reply, postId, true);
                    }
                    // Add reply form for this comment
                    if (currentUser) {
                        html += `
                            <div class="reply-form" id="reply-form-${c.id}">
                                <input type="text" class="modern-input" id="reply-input-${c.id}" placeholder="Reply to ${escapeHtml(c.author)}..." maxlength="200">
                                <button class="btn-secondary" onclick="addReply('${postId}', '${c.id}')">Reply</button>
                            </div>
                        `;
                    }
                }
                
                commentsList.innerHTML = html;
            } catch(e) {
                commentsList.innerHTML = '<p style="text-align:center; opacity:0.6; font-size:0.8rem;">Error loading comments.</p>';
            }
        }

        function renderComment(c, postId, isReply) {
            const canDelete = isAdmin;
            return `
                <div class="comment ${isReply ? 'reply' : ''}" id="comment-${c.id}">
                    <div class="comment-author">${escapeHtml(c.author || 'Unknown')}${c.is_owner ? ' <span style="background:linear-gradient(135deg,#ffd700,#ff8c00);color:#000;font-size:0.6rem;font-weight:900;padding:1px 5px;border-radius:3px;">OWNER</span>' : ''}</div>
                    <div class="comment-text">${escapeHtml(c.content)}</div>
                    <div class="comment-date">${new Date(c.created_at).toLocaleString()}</div>
                    <div class="comment-actions">
                        ${!isReply && currentUser ? `<button class="reply-btn" onclick="toggleReplyForm('${c.id}')">Reply</button>` : ''}
                        ${canDelete ? `<button class="delete-comment-btn" onclick="deleteComment('${c.id}', '${postId}')">Delete</button>` : ''}
                    </div>
                </div>
            `;
        }

        function toggleReplyForm(commentId) {
            const form = document.getElementById(`reply-form-${commentId}`);
            if (form) {
                const isVisible = form.classList.contains('visible');
                // Hide all other reply forms first
                document.querySelectorAll('.reply-form').forEach(f => f.classList.remove('visible'));
                if (!isVisible) {
                    form.classList.add('visible');
                    document.getElementById(`reply-input-${commentId}`).focus();
                }
            }
        }

        async function addReply(postId, parentCommentId) {
            if (!currentUser) return showToast('Please login to reply!', 'error');
            const input = document.getElementById(`reply-input-${parentCommentId}`);
            const content = input.value.trim();
            if (!content) return showToast('Reply cannot be empty!', 'error');
            
            try {
                const { error } = await sbClient.from('forum_comments').insert([{
                    post_id: postId,
                    parent_comment_id: parentCommentId,
                    content: content,
                    author: dbUsername || currentUser.email.split('@')[0] || 'Player',
                    user_id: currentUser.id,
                    is_owner: isAdmin
                }]);
                if (error) throw error;
                input.value = '';
                showToast('Reply posted!', 'success');
                await loadComments(postId);
                const header = document.querySelector(`#post-${postId} .comments-header span`);
                const count = await getCommentsCount(postId);
                header.textContent = `${count} comment${count !== 1 ? 's' : ''}`;
            } catch(e) { showToast('Error posting reply: ' + e.message, 'error'); }
        }

        async function addComment(postId) {
            if (!currentUser) return showToast('Please login to comment!', 'error');
            const input = document.getElementById(`comment-input-${postId}`);
            const content = input.value.trim();
            if (!content) return showToast('Comment cannot be empty!', 'error');
            
            try {
                const { error } = await sbClient.from('forum_comments').insert([{
                    post_id: postId,
                    content: content,
                    author: dbUsername || currentUser.email.split('@')[0] || 'Player',
                    user_id: currentUser.id,
                    is_owner: isAdmin
                }]);
                if (error) throw error;
                input.value = '';
                showToast('Comment posted!', 'success');
                await loadComments(postId);
                const header = document.querySelector(`#post-${postId} .comments-header span`);
                const count = await getCommentsCount(postId);
                header.textContent = `${count} comment${count !== 1 ? 's' : ''}`;
            } catch(e) { showToast('Error posting comment: ' + e.message, 'error'); }
        }

        async function deleteComment(commentId, postId) {
            if (!confirm('Delete this comment?')) return;
            try {
                const { error } = await sbClient.from('forum_comments').delete().eq('id', commentId);
                if (error) throw error;
                showToast('Comment deleted!', 'success');
                await loadComments(postId);
                const header = document.querySelector(`#post-${postId} .comments-header span`);
                const count = await getCommentsCount(postId);
                header.textContent = `${count} comment${count !== 1 ? 's' : ''}`;
            } catch(e) { showToast('Error deleting comment: ' + e.message, 'error'); }
        }

        async function createPost() {
            if (!currentUser) return showToast('Please login to post!', 'error');
            const title = document.getElementById('forum-title').value.trim();
            const desc = document.getElementById('forum-desc').value.trim();
            if (!title || !desc) return showToast('Fill all fields', 'error');
            
            try {
                const { error } = await sbClient.from('forum_posts').insert([{ 
                    title, 
                    description: desc, 
                    author: dbUsername || currentUser.email.split('@')[0] || 'Player', 
                    category: 'general',
                    user_id: currentUser.id,
                    is_owner: isAdmin
                }]);
                if (error) throw error;
                showToast('Posted!', 'success');
                document.getElementById('forum-title').value = '';
                document.getElementById('forum-desc').value = '';
                loadPosts();
            } catch(e) { showToast('Error: ' + e.message, 'error'); }
        }

        async function deletePost(postId) {
            if (!currentUser) { showToast('Please login!', 'error'); return; }
            if (!confirm('Delete this post and all its comments?')) return;
            try { 
                await sbClient.from('forum_comments').delete().eq('post_id', postId);
                const query = sbClient.from('forum_posts').delete().eq('id', postId);
                // Admin can delete any post; regular users can only delete their own
                if (!isAdmin) query.eq('user_id', currentUser.id);
                const { error } = await query;
                if (error) throw error;
                showToast('Deleted', 'success'); 
                loadPosts(); 
            } catch(e) { showToast('Error: ' + e.message, 'error'); }
        }

        function initAdminPanel() {
            // Regular powers grid
            const grid = document.getElementById('admin-powers-grid');
            if (grid) {
                grid.innerHTML = '';
                for (let key in POWERS) {
                    const p = POWERS[key];
                    grid.innerHTML += `<button class="power-grid-btn" onclick="adminGivePower('${key}')" style="border-color:${p.color};"><span style="color:${p.color};">${p.name.charAt(0)}</span><span>${p.name}</span></button>`;
                }
            }
            
            // Admin-only omega powers grid
            const omegaGrid = document.getElementById('admin-omega-grid');
            if (omegaGrid) {
                omegaGrid.innerHTML = '';
                for (let key in ADMIN_POWERS) {
                    const p = ADMIN_POWERS[key];
                    omegaGrid.innerHTML += `<button class="power-grid-btn" onclick="adminGivePower('${key}')" style="border-color:${p.color}; background: rgba(255,215,0,0.1);"><span style="color:${p.color};">${p.name.charAt(0)}</span><span>${p.name}</span></button>`;
                }
            }
            
            // Spawn power select (regular + admin powers)
            const select = document.getElementById('spawn-power-select');
            if (select) {
                select.innerHTML = '<option value="">Select...</option>';
                for (let key in POWERS) select.innerHTML += `<option value="${key}">${POWERS[key].name}</option>`;
                select.innerHTML += '<option disabled>‚îÄ‚îÄ Admin Powers ‚îÄ‚îÄ</option>';
                for (let key in ADMIN_POWERS) select.innerHTML += `<option value="${key}">${ADMIN_POWERS[key].name}</option>`;
            }
        }

        function toggleAdminPanel() { if (isAdmin) document.getElementById('admin-panel').classList.toggle('visible'); }

        function adminGivePower(powerKey) {
            if (!isAdmin || !state.me) return;
            state.me.currentPower = powerKey;
            state.me.isOmegaPower = !!(OMEGA_POWER[powerKey]);
            state.me.isAdminPower = !!(ADMIN_POWERS[powerKey]);
            updatePowerUI(powerKey);
            broadcastState();
            showToast(`Got ${ALL_POWERS[powerKey].name}!`, 'admin');
        }

        function adminAction(action) {
            if (!isAdmin || !state.me) return;
            switch(action) {
                case 'heal':
                    state.me.hp = 100;
                    spawnParticles(state.me.x, state.me.y, 30, '#22c55e');
                    showToast('Full heal!', 'admin');
                    break;
                case 'kill_all':
                    for (let id in state.players) forceKillPlayer(id);
                    showToast('Killed all!', 'admin');
                    break;
                case 'teleport_center':
                    state.me.x = CONFIG.map.width / 2;
                    state.me.y = CONFIG.map.height / 2;
                    emitAbilityEffect('teleport', state.me.x, state.me.y);
                    showToast('Teleported!', 'admin');
                    break;
                case 'add_kills':
                    state.kills += 10;
                    state.me.kills = state.kills;
                    updateKillCounter();
                    if (state.kills >= state.nextOmegaThreshold && !state.omegaUnlocked) unlockOmega();
                    showToast('+10 kills!', 'admin');
                    break;
                case 'toggle_godmode':
                    state.adminGodMode = !state.adminGodMode;
                    document.getElementById('godmode-btn').textContent = `God Mode: ${state.adminGodMode ? 'ON' : 'OFF'}`;
                    document.getElementById('godmode-btn').classList.toggle('active', state.adminGodMode);
                    showToast(`God Mode: ${state.adminGodMode ? 'ON' : 'OFF'}`, 'admin');
                    break;
                case 'toggle_infinite':
                    state.adminInfinite = !state.adminInfinite;
                    document.getElementById('infinite-btn').textContent = `Infinite Power: ${state.adminInfinite ? 'ON' : 'OFF'}`;
                    document.getElementById('infinite-btn').classList.toggle('active', state.adminInfinite);
                    showToast(`Infinite: ${state.adminInfinite ? 'ON' : 'OFF'}`, 'admin');
                    break;
                case 'spawn_power':
                    const sel = document.getElementById('spawn-power-select').value;
                    if (sel && ALL_POWERS[sel]) {
                        const dropId = 'admin_' + Date.now();
                        state.powerups[dropId] = { id: dropId, type: sel, x: state.mouse.worldX, y: state.mouse.worldY };
                        spawnParticles(state.mouse.worldX, state.mouse.worldY, 20, ALL_POWERS[sel].color);
                        showToast(`Spawned ${ALL_POWERS[sel].name}!`, 'admin');
                    }
                    break;
                case 'heal_all':
                    for (let id in state.players) {
                        socket.emit('playerHit', { targetId: id, damage: -100, attackerId: myId });
                        spawnParticles(state.players[id].x, state.players[id].y, 15, '#22c55e');
                    }
                    showToast('Healed everyone!', 'admin');
                    break;
                case 'clear_powerups':
                    state.powerups = {};
                    showToast('Cleared all powerups!', 'admin');
                    break;
                case 'respawn_all':
                    for (let id in state.players) {
                        socket.emit('playerDied', { victimId: id, killerId: myId });
                    }
                    showToast('Respawned all!', 'admin');
                    break;
            }
        }

        function adminSpawnBoss() {
            if (!isAdmin || !socket) return;
            socket.emit('adminAnnouncement', { message: '‚ö†Ô∏è Admin is spawning the BOSS!' });
            // Tell server to spawn boss immediately via a special emit
            socket.emit('adminSpawnBoss');
            showToast('Boss spawning!', 'admin');
        }

        function sendAnnouncement() {
            if (!isAdmin || !socket) return;
            const text = document.getElementById('announce-text').value.trim();
            if (!text) return showToast('Type something to announce!', 'warning');
            socket.emit('adminAnnouncement', { message: text });
            document.getElementById('announce-text').value = '';
            showToast('Announcement sent!', 'admin');
        }

        function showAnnouncement(msg) {
            const el = document.getElementById('game-announcement');
            const msgEl = document.getElementById('announce-message');
            msgEl.textContent = msg;
            el.classList.remove('visible');
            // Force reflow to restart animation
            void el.offsetWidth;
            el.classList.add('visible');
            setTimeout(() => el.classList.remove('visible'), 5000);
        }

        function emitAbilityEffect(type, x, y, extra = {}) {
            if (!socket) return;
            socket.emit('abilityUsed', { type, x, y, id: myId, ...extra });
        }

        function broadcastState() {
            if (!socket || !state.me) return;
            socket.emit('move', {
                x: state.me.x, y: state.me.y, angle: state.me.angle, kills: state.kills,
                currentPower: state.me.currentPower, hp: state.me.hp, speedActive: state.speedActive,
                berserkerActive: state.berserkerActive, phaseActive: state.phaseActive,
                mirrorActive: state.mirrorActive, isOwner: isAdmin
            });
        }

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

       function joinGame() {
    if (isConnecting) return;
    if (typeof io === 'undefined') return showToast('Server Error', 'error');

    const playBtn = document.getElementById('play-btn');
    const connectStatus = document.getElementById('connecting-status');
    isConnecting = true;
    playBtn.disabled = true;
    connectStatus.style.display = 'block';
    connectionAttempts++;
    connectStatus.textContent = `Connecting... (${connectionAttempts})`;

    const name = document.getElementById('username-input').value.trim() || dbUsername || 'Guest';
    if (socket) { socket.disconnect(); socket = null; }

    let connectionTimeout = setTimeout(() => {
        if (isConnecting) {
            isConnecting = false;
            playBtn.disabled = false;
            connectStatus.style.display = 'none';
            showToast('Connection timeout! Server may be waking up...', 'warning');
            if (socket) socket.disconnect();
            socket = null;
        }
    }, 20000);

    socket = io(CONFIG.serverUrl, { 
        timeout: 15000, 
        reconnectionAttempts: 5,
        transports: ['websocket', 'polling']
    });

    socket.on('connect', () => {
        myId = socket.id;
        const userId = currentUser ? currentUser.id : null;
        socket.emit('join', { name, userId });
    });

    socket.on('duplicateSession', (data) => {
        clearTimeout(connectionTimeout);
        isConnecting = false;
        playBtn.disabled = false;
        connectStatus.style.display = 'none';
        showToast(data.message || 'This account is already playing!', 'error');
        socket.disconnect();
        socket = null;
    });

    socket.on('joinSuccess', () => {
        clearTimeout(connectionTimeout);
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('top-left-ui').style.display = 'none';
        document.getElementById('top-right-ui').style.display = 'none';
        document.getElementById('hud-bottom').style.display = 'flex';
        document.getElementById('leaderboard').style.display = 'block';
        document.getElementById('chat-wrap').style.display = 'block';
        document.getElementById('kill-counter').style.display = 'block';
        if (isAdmin) document.getElementById('admin-toggle').style.display = 'block';
        isConnecting = false;
        connectionAttempts = 0;
        // Announce owner joining to everyone
        if (isAdmin && socket) {
            socket.emit('adminAnnouncement', { message: 'üëë The Owner Astraphobia Has Joined!' });
        }
    });

    socket.on('connect_error', (error) => {
        connectStatus.textContent = `Connecting... (${connectionAttempts}) - Retrying...`;
        if (connectionAttempts >= 5) {
            clearTimeout(connectionTimeout);
            isConnecting = false;
            playBtn.disabled = false;
            connectStatus.style.display = 'none';
            showToast('Cannot reach server! Try again later.', 'error');
            connectionAttempts = 0;
        }
    });

    socket.on('disconnect', () => { 
        clearTimeout(connectionTimeout);
        if (state.running) { 
            showToast('Disconnected!', 'error'); 
            state.running = false; 
        } 
    });

    setupSocketHandlers();
}

        function resetGameState() {
            state.me = null; state.players = {}; state.projectiles = {}; state.powerups = {};
            state.particles = []; state.clones = []; state.explosions = []; state.meteors = []; state.timebombs = [];
            state.remoteClones = {}; state.speedActive = false; state.phaseActive = false;
            state.berserkerActive = false; state.shootCooldown = 0; state.cloneTimer = 0;
            state.kills = 0; state.omegaUnlocked = false; state.omegaPower = null;
            state.omegaTimer = 0; state.mirrorActive = false;
            state.timestopActive = false; state.hitCooldowns = {}; state.isDead = false;
            state.nextOmegaThreshold = 10; state.baby = null; state.babyShootCooldown = 0; state.remoteBabies = {};
            state.bosses = {};
            updateKillCounter();
        }

        function setupSocketHandlers() {
            socket.on('init', (data) => {
                // Reset game state at the START of init
                state.particles = []; state.clones = []; state.explosions = []; state.meteors = []; state.timebombs = [];
                state.remoteClones = {}; state.speedActive = false; state.phaseActive = false;
                state.berserkerActive = false; state.shootCooldown = 0; state.cloneTimer = 0;
                state.kills = 0; state.omegaUnlocked = false; state.omegaPower = null;
                state.omegaTimer = 0; state.adminGodMode = false; state.adminInfinite = false;
                state.mirrorActive = false; state.timestopActive = false; state.hitCooldowns = {}; state.isDead = false;
                state.nextOmegaThreshold = 10; state.baby = null; state.babyShootCooldown = 0; state.remoteBabies = {};
                
                state.me = data.player;
                state.me.recoil = 0; state.me.poisoned = 0; state.me.frozen = 0;
                state.me.kills = 0; state.me.isOmegaPower = false;
                state.players = {};
                Object.keys(data.players || {}).forEach(id => {
                    if (id !== myId) { state.players[id] = data.players[id]; state.players[id].kills = 0; }
                });
                state.projectiles = data.projectiles || {};
                state.powerups = data.powerups || {};
                // Load existing bosses from server state
                if (data.bosses) {
                    for (const id in data.bosses) {
                        state.bosses[id] = { ...data.bosses[id], targetX: data.bosses[id].x, targetY: data.bosses[id].y };
                    }
                }
                
                updateKillCounter();
                
                // Start game loop here after player data is loaded
                if (!state.running) {
                    state.running = true;
                    state.lastTime = performance.now();
                    requestAnimationFrame(loop);
                }
            });

            socket.on('playerJoined', p => { if (p.id !== myId) { state.players[p.id] = p; state.players[p.id].kills = 0; } });
            socket.on('playerLeft', id => { delete state.players[id]; delete state.remoteClones[id]; if (state.remoteBabies) delete state.remoteBabies[id]; });

            socket.on('playerMoved', (data) => {
                if (data.id !== myId && state.players[data.id]) {
                    const p = state.players[data.id];
                    p.targetX = data.x; p.targetY = data.y; p.angle = data.angle;
                    if (data.currentPower !== undefined) p.currentPower = data.currentPower;
                    if (data.kills !== undefined) p.kills = data.kills;
                    if (data.hp !== undefined) p.hp = data.hp;
                    if (data.speedActive !== undefined) p.speedActive = data.speedActive;
                    if (data.berserkerActive !== undefined) p.berserkerActive = data.berserkerActive;
                    if (data.phaseActive !== undefined) p.phaseActive = data.phaseActive;
                    if (data.mirrorActive !== undefined) p.mirrorActive = data.mirrorActive;
                    if (data.isOwner !== undefined) p.isOwner = data.isOwner;
                }
            });

            socket.on('powerupSpawn', p => { if (p && p.id && p.type && ALL_POWERS[p.type]) state.powerups[p.id] = p; });
            socket.on('powerupTaken', id => delete state.powerups[id]);
            
            // Auto-spawn extra powerups client-side to keep map full
            function autoSpawnPowerups() {
                const currentCount = Object.keys(state.powerups).length;
                const target = 35; // Keep at least 35 powerups on map
                if (currentCount < target && state.running) {
                    const spawnCount = Math.min(5, target - currentCount);
                    const powerKeys = Object.keys(POWERS);
                    // Weight toward mythic/legendary
                    const weightedKeys = powerKeys.filter(k => k !== 'baby');
                    for (let i = 0; i < spawnCount; i++) {
                        const key = weightedKeys[Math.floor(Math.random() * weightedKeys.length)];
                        const id = 'auto_' + (powerupIdCounter++);
                        state.powerups[id] = {
                            id, type: key,
                            x: 100 + Math.random() * (CONFIG.map.width - 200),
                            y: 100 + Math.random() * (CONFIG.map.height - 200)
                        };
                    }
                }
                if (state.running) setTimeout(autoSpawnPowerups, 3000);
            }
            setTimeout(autoSpawnPowerups, 5000);
            // Initial bulk spawn on game start
            setTimeout(() => {
                if (!state.running) return;
                const allPowerKeys = Object.keys(POWERS).filter(k => k !== 'baby');
                for (let i = 0; i < 40; i++) {
                    const key = allPowerKeys[Math.floor(Math.random() * allPowerKeys.length)];
                    const id = 'init_' + (powerupIdCounter++);
                    state.powerups[id] = {
                        id, type: key,
                        x: 100 + Math.random() * (CONFIG.map.width - 200),
                        y: 100 + Math.random() * (CONFIG.map.height - 200)
                    };
                }
                // Spawn 1 of each mythic powerup on map start
                ['baby', 'phoenix', 'soulsteal'].forEach((k, i) => {
                    const id = 'mythic_' + i;
                    state.powerups[id] = {
                        id, type: k,
                        x: 200 + Math.random() * (CONFIG.map.width - 400),
                        y: 200 + Math.random() * (CONFIG.map.height - 400)
                    };
                });
            }, 3000);

            // Force position update (from swap)
            socket.on('forceMovePlayer', (data) => {
                if (state.me && !state.isDead) {
                    spawnParticles(state.me.x, state.me.y, 20, '#ec4899');
                    state.me.x = data.x;
                    state.me.y = data.y;
                    spawnParticles(state.me.x, state.me.y, 20, '#ec4899');
                    broadcastState();
                    showToast('You got swapped!', 'warning');
                }
            });

            // Admin announcement
            socket.on('announcement', (data) => {
                showAnnouncement(data.message);
            });

            socket.on('chatMessage', data => {
                const history = document.getElementById('chat-history');
                const div = document.createElement('div');
                div.className = 'chat-msg';
                div.innerHTML = `<b>${escapeHtml(data.playerName)}:</b> ${escapeHtml(data.text)}`;
                history.appendChild(div);
                history.scrollTop = history.scrollHeight;
            });

            // ‚îÄ‚îÄ BOSS EVENTS ‚îÄ‚îÄ
            socket.on('bossSpawn', (data) => {
                state.bosses[data.id] = { ...data, targetX: data.x, targetY: data.y };
                spawnParticles(data.x, data.y, 80, '#ff0000');
            });

            socket.on('bossMoved', (data) => {
                if (!state.bosses[data.bossId]) state.bosses[data.bossId] = { id: data.bossId, maxHp: 1000 };
                const b = state.bosses[data.bossId];
                b.targetX = data.x;
                b.targetY = data.y;
                b.angle = data.angle;
                b.hp = data.hp;
            });

            socket.on('bossDied', (data) => {
                const b = state.bosses[data.bossId];
                if (b) {
                    state.explosions.push({ x: b.x || data.bossX, y: b.y || data.bossY, radius: 80, maxRadius: 600, life: 2, color: '#ff0000' });
                    for (let i = 0; i < 100; i++) spawnParticles(data.bossX, data.bossY, 1, ['#ff0000','#ffd700','#ff6b00'][Math.floor(Math.random()*3)]);
                }
                delete state.bosses[data.bossId];
                if (data.drops) {
                    data.drops.forEach(d => { if (ALL_POWERS[d.type]) state.powerups[d.id] = d; });
                }
            });

            socket.on('playerDied', data => {
                if (data.victimId === myId && !state.isDead) {
                    state.me.hp = 0;
                    handleDeath(data.killerId);
                }
                if (state.players[data.victimId]) {
                    state.players[data.victimId].hp = 0;
                    spawnParticles(state.players[data.victimId].x, state.players[data.victimId].y, 30, '#ef4444');
                    state.players[data.victimId].kills = 0;
                    delete state.remoteClones[data.victimId];
                    if (state.remoteBabies) delete state.remoteBabies[data.victimId];
                }
                if (data.killerId === myId && data.victimId !== myId) {
                    state.kills++;
                    state.me.kills = state.kills;
                    updateKillCounter();
                    showToast(`Kill! (${state.kills}/${state.nextOmegaThreshold})`, 'kill');
                    if (state.kills >= state.nextOmegaThreshold && !state.omegaUnlocked) unlockOmega();
                }
            });

            socket.on('playerHit', data => {
                if (data.targetId === myId && state.me && !state.isDead) {
                    if (state.adminGodMode) return;
                    if (state.mirrorActive && data.attackerId) {
                        socket.emit('playerHit', { targetId: data.attackerId, damage: data.damage, attackerId: myId });
                        spawnParticles(state.me.x, state.me.y, 10, '#c0c0c0');
                        return;
                    }
                    let damage = data.damage || 20;
                    if (state.me.currentPower === 'shield') damage = Math.floor(damage * 0.5);
                    if (state.me.currentPower === 'tank') damage = Math.floor(damage * 0.25);
                    if (state.me.currentPower === 'berserker' && state.berserkerActive) damage *= 2;
                    state.me.hp -= damage;
                    spawnDamageNumber(state.me.x, state.me.y, damage, 'damage');
                    spawnParticles(state.me.x, state.me.y, 10, '#ef4444');
                    if (state.me.hp <= 0 && !state.isDead) {
                        if (state.me.currentPower === 'phoenix') {
                            // Phoenix revive!
                            state.me.hp = 80;
                            state.me.currentPower = null;
                            updatePowerUI(null);
                            spawnParticles(state.me.x, state.me.y, 60, '#ff6600');
                            state.explosions.push({ x: state.me.x, y: state.me.y, radius: 20, maxRadius: 200, life: 1, color: '#ff6600' });
                            showToast('üî• PHOENIX REVIVED! +80 HP', 'mythic');
                            broadcastState();
                        } else {
                            state.isDead = true;
                            socket.emit('playerDied', { victimId: myId, killerId: data.attackerId });
                        }
                    }
                }
            });

            socket.on('remoteShoot', data => {
                if (data.ownerId === myId) return;
                const id = 'remote_' + Math.random();
                state.projectiles[id] = {
                    id, x: data.x, y: data.y, angle: data.angle, type: data.type,
                    speed: data.speed || 600, color: data.color || '#ef4444', life: 3,
                    owner: data.ownerId, damage: data.damage || 20, localUpdate: true, isRemote: true
                };
            });

            socket.on('abilityEffect', data => {
                const { type, x, y, id } = data;
                if (id === myId) return;
                switch(type) {
                    // ‚îÄ‚îÄ EXISTING EFFECTS ‚îÄ‚îÄ
                    case 'laserbeam':
                        state.laserBeams.push({ x1: x, y1: y, x2: data.x2, y2: data.y2, life: 1 });
                        break;
                    case 'rockettrail':
                        state.rocketTrails.push({ x, y, life: 1 });
                        spawnParticles(x, y, 5, '#fb923c');
                        break;
                    case 'nuke':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 400, life: 1, color: '#dc2626' });
                        for (let i = 0; i < 60; i++) spawnParticles(x, y, 1, ['#dc2626', '#f59e0b', '#fbbf24'][Math.floor(Math.random() * 3)]);
                        break;
                    case 'dash': spawnParticles(x, y, 15, '#f59e0b'); break;
                    case 'teleport': spawnParticles(x, y, 20, '#10b981'); break;
                    case 'heal': spawnParticles(x, y, 20, '#22c55e'); break;
                    case 'blackhole':
                        state.explosions.push({ x, y, radius: 10, maxRadius: 200, life: 1.5, color: '#1e1b4b' });
                        spawnParticles(x, y, 40, '#4c1d95');
                        break;
                    case 'shockwave':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 200, life: 0.5, color: '#8b5cf6' });
                        break;
                    case 'emp':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 250, life: 0.8, color: '#6366f1' });
                        spawnParticles(x, y, 30, '#6366f1');
                        break;
                    case 'swap': spawnParticles(x, y, 20, '#ec4899'); break;
                    case 'clone':
                        spawnParticles(x, y, 40, '#14b8a6');
                        if (!state.remoteClones[id]) state.remoteClones[id] = [];
                        for (let i = 0; i < 3; i++) {
                            state.remoteClones[id].push({
                                ownerId: id, offsetAngle: (i * (Math.PI * 2) / 3), timer: 12,
                                x: x, y: y, angle: 0, name: state.players[id] ? state.players[id].name : 'Clone',
                                hp: 50, kills: 0, currentPower: 'clone'
                            });
                        }
                        break;
                    case 'annihilator':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 500, life: 1, color: '#ff0000' });
                        for (let i = 0; i < 50; i++) spawnParticles(x, y, 1, '#ff0000');
                        break;
                    case 'meteor':
                        for (let i = 0; i < 10; i++) {
                            state.meteors.push({
                                x: x + (Math.random() - 0.5) * 400,
                                y: y - 200 - Math.random() * 200,
                                targetY: y + Math.random() * 300,
                                speed: 400 + Math.random() * 200
                            });
                        }
                        break;
                    case 'vortex':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 600, life: 2, color: '#7c3aed' });
                        break;
                    case 'supernova':
                        state.explosions.push({ x, y, radius: 100, maxRadius: 1000, life: 1.5, color: '#fff700' });
                        for (let i = 0; i < 100; i++) spawnParticles(x, y, 1, ['#fff700', '#ffd700', '#ff6b00'][Math.floor(Math.random() * 3)]);
                        break;

                    // ‚îÄ‚îÄ NEWLY SYNCED EFFECTS ‚îÄ‚îÄ
                    case 'lightning':
                        // 3 delayed bolts in the target area - use pre-generated positions if available
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                const bx = (data.pts && data.pts[i]) ? data.pts[i].x : x + (Math.random()-0.5)*80;
                                const by = (data.pts && data.pts[i]) ? data.pts[i].y : y + (Math.random()-0.5)*80;
                                state.explosions.push({ x: bx, y: by, radius: 5, maxRadius: 80, life: 0.5, color: '#facc15' });
                                spawnParticles(bx, by, 20, '#facc15');
                            }, i * 120);
                        }
                        break;
                    case 'poison':
                        state.explosions.push({ x, y, radius: 10, maxRadius: 180, life: 1.5, color: '#84cc16' });
                        spawnParticles(x, y, 40, '#84cc16');
                        break;
                    case 'poisontick':
                        // Ongoing poison cloud particles
                        for (let i = 0; i < 5; i++) {
                            spawnParticles(x + (Math.random()-0.5)*180, y + (Math.random()-0.5)*180, 1, '#84cc16');
                        }
                        break;
                    case 'frostnova':
                        state.explosions.push({ x, y, radius: 40, maxRadius: 300, life: 1, color: '#a5f3fc' });
                        for (let i = 0; i < 50; i++) {
                            const ang = (i / 50) * Math.PI * 2;
                            const d = 50 + Math.random() * 250;
                            spawnParticles(x + Math.cos(ang)*d, y + Math.sin(ang)*d, 3, '#a5f3fc');
                        }
                        break;
                    case 'gravitypull':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 400, life: 1, color: '#7c3aed' });
                        for (let i = 0; i < 40; i++) {
                            const ang = (i / 40) * Math.PI * 2;
                            spawnParticles(x + Math.cos(ang)*400, y + Math.sin(ang)*400, 2, '#7c3aed');
                        }
                        break;
                    case 'soulrip':
                        state.explosions.push({ x, y, radius: 20, maxRadius: 380, life: 1.2, color: '#7c00ff' });
                        spawnParticles(x, y, 60, '#a855f7');
                        for (let i = 0; i < 20; i++) {
                            const ang = (i / 20) * Math.PI * 2;
                            spawnParticles(x + Math.cos(ang) * 380, y + Math.sin(ang) * 380, 3, '#7c00ff');
                        }
                        break;
                    case 'timebomb':
                        // Add to timebombs list - same small pulsing indicator as caster sees
                        spawnParticles(x, y, 20, '#ff6b00');
                        state.timebombs.push({ id: data.bombId || ('rbomb_' + Date.now()), x, y, timer: 2.0 });
                        break;
                    case 'timebombexplode':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 250, life: 0.8, color: '#ff6b00' });
                        for (let i = 0; i < 40; i++) spawnParticles(x, y, 1, '#ff6b00');
                        // Remove matching timebomb indicator
                        if (data.bombId) {
                            const rbi = state.timebombs.findIndex(b => b.id === data.bombId);
                            if (rbi !== -1) state.timebombs.splice(rbi, 1);
                        }
                        break;
                    case 'orbitallaser':
                        // Warning flash before strike
                        for (let i = 0; i < 30; i++) spawnParticles(x + (Math.random()-0.5)*100, -50, 1, '#00f5ff');
                        state.explosions.push({ x, y, radius: 10, maxRadius: 50, life: 1.5, color: '#00f5ff' });
                        break;
                    case 'orbitallaserfire':
                        for (let i = 0; i < 100; i++) spawnParticles(x, i * 50, 2, '#00f5ff');
                        state.explosions.push({ x, y, radius: 40, maxRadius: 200, life: 1, color: '#00f5ff' });
                        break;
                    case 'shadowclone':
                        spawnParticles(x, y, 30, '#1a1a2e');
                        state.explosions.push({ x, y, radius: 10, maxRadius: 40, life: 1, color: '#1a1a2e' });
                        break;
                    case 'shadowcloneexplode':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 180, life: 0.6, color: '#1a1a2e' });
                        spawnParticles(x, y, 20, '#1a1a2e');
                        break;
                    case 'chaos':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 250, life: 1, color: '#ec4899' });
                        spawnParticles(x, y, 50, '#ec4899');
                        break;
                    case 'mirror':
                        for (let i = 0; i < 20; i++) {
                            const ang = (i / 20) * Math.PI * 2;
                            spawnParticles(x + Math.cos(ang)*50, y + Math.sin(ang)*50, 2, '#c0c0c0');
                        }
                        state.explosions.push({ x, y, radius: 10, maxRadius: 60, life: 0.5, color: '#c0c0c0' });
                        break;
                    // Baby tracking
                    case 'babyspawn':
                        if (!state.remoteBabies) state.remoteBabies = {};
                        state.remoteBabies[id] = { x, y, angle: 0, hp: 50 };
                        spawnParticles(x, y, 30, '#ff69b4');
                        break;
                    case 'babypos':
                        if (!state.remoteBabies) state.remoteBabies = {};
                        if (!state.remoteBabies[id]) state.remoteBabies[id] = { x, y, angle: data.angle || 0, hp: data.hp || 50 };
                        state.remoteBabies[id].x = x; state.remoteBabies[id].y = y;
                        state.remoteBabies[id].angle = data.angle || 0; state.remoteBabies[id].hp = data.hp || 50;
                        break;
                    case 'babyrecall':
                    case 'babydied':
                    case 'babydestruct':
                        if (state.remoteBabies) delete state.remoteBabies[id];
                        spawnParticles(x, y, 20, '#ff69b4');
                        if (type === 'babydestruct') {
                            state.explosions.push({ x, y, radius: 20, maxRadius: 200, life: 0.8, color: '#ff69b4' });
                        }
                        break;
                    // ‚îÄ‚îÄ ADMIN POWER EFFECTS ‚îÄ‚îÄ
                    case 'apocalypse':
                        if (data.pts) data.pts.forEach((pt, i) => {
                            setTimeout(() => {
                                state.explosions.push({ x: pt.x, y: pt.y, radius: 40, maxRadius: 300, life: 1, color: '#ff0000' });
                                spawnParticles(pt.x, pt.y, 15, '#ff0000');
                            }, i * 200);
                        });
                        break;
                    case 'chronobreak':
                        if (data.pts) data.pts.forEach(pt => spawnParticles(pt.x, pt.y, 1, '#00ffff'));
                        else for (let i = 0; i < 100; i++) spawnParticles(x + (Math.random()-0.5)*500, y + (Math.random()-0.5)*500, 1, '#00ffff');
                        state.explosions.push({ x, y, radius: 50, maxRadius: 400, life: 2, color: '#00ffff' });
                        break;
                    case 'voidrift':
                        state.explosions.push({ x, y, radius: 100, maxRadius: 800, life: 2, color: '#9333ea' });
                        spawnParticles(x, y, 60, '#9333ea');
                        break;
                    case 'armageddon':
                        if (data.pts) data.pts.forEach(pt => {
                            setTimeout(() => {
                                state.meteors.push({ x: pt.x, y: -400, targetY: pt.y, speed: 1200 });
                            }, pt.delay || 0);
                        });
                        break;
                    case 'omegabeam':
                        if (data.angle !== undefined) {
                            for (let i = 0; i < 100; i++) {
                                spawnParticles(x + Math.cos(data.angle)*i*50, y + Math.sin(data.angle)*i*50, 3, '#06b6d4');
                            }
                        }
                        state.explosions.push({ x, y, radius: 50, maxRadius: 5000, life: 1.5, color: '#06b6d4' });
                        break;
                    case 'singularity':
                        state.explosions.push({ x, y, radius: 10, maxRadius: 600, life: 5, color: '#000000' });
                        for (let i = 0; i < 5; i++) setTimeout(() => spawnParticles(x, y, 30, '#000000'), i * 500);
                        break;
                    case 'realitybomb':
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                const d = (i / 20) * 500;
                                for (let ang = 0; ang < Math.PI * 2; ang += 0.5) {
                                    spawnParticles(x + Math.cos(ang)*d, y + Math.sin(ang)*d, 2, '#ec4899');
                                }
                            }, i * 50);
                        }
                        break;
                    case 'godmode':
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                state.explosions.push({ x, y, radius: 50, maxRadius: 400, life: 0.5, color: '#ffd700' });
                            }, i * 300);
                        }
                        spawnParticles(x, y, 50, '#ffd700');
                        break;
                    case 'obliterate':
                        if (data.pts) data.pts.forEach(pt => {
                            state.explosions.push({ x: pt.x, y: pt.y, radius: 100, maxRadius: 600, life: 1, color: '#dc2626' });
                            spawnParticles(pt.x, pt.y, 20, '#dc2626');
                        });
                        break;
                    case 'dimensionrift':
                        state.explosions.push({ x, y, radius: 100, maxRadius: 1000, life: 2, color: '#8b00ff' });
                        spawnParticles(x, y, 80, '#8b00ff');
                        break;
                    case 'cosmicstorm':
                        for (let wave = 0; wave < 8; wave++) {
                            setTimeout(() => {
                                const ang = (wave / 8) * Math.PI * 2;
                                for (let d = 0; d < 1000; d += 100) {
                                    spawnParticles(x + Math.cos(ang)*d, y + Math.sin(ang)*d, 3, '#ff1493');
                                }
                            }, wave * 300);
                        }
                        break;
                    case 'infinityvoid':
                        for (let wave = 0; wave < 15; wave++) {
                            setTimeout(() => {
                                const r = wave * 40;
                                state.explosions.push({ x, y, radius: r, maxRadius: r + 100, life: 0.5, color: '#000033' });
                                spawnParticles(x, y, 10, '#000033');
                            }, wave * 200);
                        }
                        break;
                    case 'starforge':
                        for (let i = 0; i < 5; i++) {
                            const sX = x + Math.cos(i * Math.PI * 0.4) * 300;
                            const sY = y + Math.sin(i * Math.PI * 0.4) * 300;
                            for (let tick = 0; tick < 20; tick++) {
                                setTimeout(() => {
                                    state.explosions.push({ x: sX, y: sY, radius: 50, maxRadius: 150, life: 0.5, color: '#ffdf00' });
                                    spawnParticles(sX, sY, 5, '#ffdf00');
                                }, (i * 500) + (tick * 200));
                            }
                        }
                        break;
                    case 'quantumcollapse':
                        if (data.pts) {
                            for (let i = 0; i < 100; i++) spawnParticles(data.pts[i % 30].x, data.pts[i % 30].y, 1, '#00fff7');
                            for (let wave = 0; wave < 6; wave++) {
                                setTimeout(() => {
                                    for (let j = 0; j < 5; j++) {
                                        const pt = data.pts[(wave*5+j) % 30];
                                        state.explosions.push({ x: pt.x, y: pt.y, radius: 50, maxRadius: 400, life: 1, color: '#00fff7' });
                                    }
                                }, wave * 400);
                            }
                        }
                        break;
                    case 'worldender':
                        // Ring pattern is deterministic from x,y - recreate it
                        for (let ring = 0; ring < 5; ring++) {
                            setTimeout(() => {
                                for (let i = 0; i < 12; i++) {
                                    const ang = (i / 12) * Math.PI * 2;
                                    const r = (ring + 1) * 400;
                                    state.explosions.push({ x: x + Math.cos(ang)*r, y: y + Math.sin(ang)*r, radius: 50, maxRadius: 300, life: 1, color: '#b91c1c' });
                                }
                            }, ring * 250);
                        }
                        break;
                    case 'divinebeam':
                        spawnParticles(x, y, 30, '#f0abfc');
                        break;
                    case 'divinebeamtarget':
                        for (let tick = 0; tick < 10; tick++) {
                            setTimeout(() => {
                                spawnParticles(x, y - tick*30, 5, '#f0abfc');
                                state.explosions.push({ x, y, radius: 10, maxRadius: 60, life: 0.4, color: '#f0abfc' });
                            }, tick * 100);
                        }
                        break;
                    case 'blacksun':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 2000, life: 3, color: '#1c1c1c' });
                        for (let i = 0; i < 10; i++) setTimeout(() => spawnParticles(x, y, 20, '#1c1c1c'), i * 200);
                        break;
                    case 'stormcall':
                        if (data.pts) data.pts.forEach((pt, bolt) => {
                            setTimeout(() => {
                                state.explosions.push({ x: pt.x, y: pt.y, radius: 5, maxRadius: 120, life: 0.4, color: '#60a5fa' });
                                spawnParticles(pt.x, pt.y, 10, '#60a5fa');
                            }, bolt * 150);
                        });
                        break;
                }
            });
        }

        function handleDeath(killerId) {
            state.isDead = true; state.respawnTimer = 3;
            document.getElementById('death-screen').classList.add('active');
            state.omegaUnlocked = false; state.omegaPower = null;
            state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
            state.mirrorActive = false; state.timestopActive = false; state.clones = []; state.cloneTimer = 0;
            // Always clear current power on death ‚Äî no power survives respawn
            state.me.currentPower = null; state.me.isOmegaPower = false; state.me.isAdminPower = false;
            // Clear all hit cooldowns so boss/players can re-hit after respawn
            state.hitCooldowns = {};
            updateKillCounter(); updatePowerUI(null); updateScreenEffects();
        }

        function respawn() {
            state.isDead = false;
            document.getElementById('death-screen').classList.remove('active');
            state.me.hp = 100;
            state.me.x = 200 + Math.random() * (CONFIG.map.width - 400);
            state.me.y = 200 + Math.random() * (CONFIG.map.height - 400);
            state.me.currentPower = null; state.me.isOmegaPower = false; state.me.isAdminPower = false;
            state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
            state.mirrorActive = false; state.timestopActive = false;
            state.hitCooldowns = {};
            updatePowerUI(null); updateScreenEffects();
            spawnParticles(state.me.x, state.me.y, 20, '#00f2fe');
            broadcastState();
        }

        function forceKillPlayer(targetId) {
            if (!state.players[targetId]) return;
            socket.emit('playerDied', { victimId: targetId, killerId: myId });
        }

        function unlockOmega() {
            state.omegaUnlocked = true;
            state.omegaPower = 'meteor';
            document.getElementById('omega-power-name').textContent = OMEGA_POWER.meteor.name;
            document.getElementById('omega-unlock-overlay').classList.add('active');
            setTimeout(() => {
                document.getElementById('omega-unlock-overlay').classList.remove('active');
                showToast(`OMEGA: ${OMEGA_POWER.meteor.name}! Press Q!`, 'omega');
            }, 2500);
            updateKillCounter();
        }

        function updateKillCounter() {
            const threshold = state.nextOmegaThreshold || 10;
            document.getElementById('kill-count').textContent = state.kills;
            const threshEl = document.getElementById('kill-threshold');
            if (threshEl) threshEl.textContent = threshold;
            const counter = document.getElementById('kill-counter');
            const omegaReady = document.getElementById('omega-ready');
            counter.classList.toggle('close-to-omega', state.kills >= threshold - 3 && !state.omegaUnlocked);
            if (state.omegaUnlocked && state.omegaPower) {
                omegaReady.style.display = 'inline';
                omegaReady.textContent = `[Q] ${OMEGA_POWER[state.omegaPower].name}`;
            } else { omegaReady.style.display = 'none'; }
        }

        function loop(timestamp) {
            if (!state.running) return;
            const dt = Math.min((timestamp - state.lastTime) / 1000, 0.1);
            state.lastTime = timestamp;
            if (state.isDead) {
                state.respawnTimer -= dt;
                document.getElementById('respawn-countdown').textContent = Math.ceil(state.respawnTimer);
                if (state.respawnTimer <= 0) respawn();
            } else { 
                update(dt); 
            }
            render();
            requestAnimationFrame(loop);
        }

        function update(dt) {
            if (!state.me) return;
            if (state.shootCooldown > 0) state.shootCooldown -= dt;
            if (state.me.poisoned > 0) {
                state.me.poisoned -= dt;
                if (Math.random() < 0.1 && !state.adminGodMode) {
                    state.me.hp -= 1;
                    spawnDamageNumber(state.me.x, state.me.y, 1, 'damage');
                }
            }
            if (state.me.frozen > 0) state.me.frozen -= dt;
            if (state.me.currentPower === 'regeneration' && state.me.hp < 100) {
                state.me.hp = Math.min(100, state.me.hp + dt * 3);
            }
            // Thorns: large thorn growths slow and damage nearby enemies increasingly
            if (state.me.currentPower === 'thorns') {
                const thornRange = 180;
                for (let id in state.players) {
                    const p = state.players[id];
                    const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                    if (dist < thornRange) {
                        // Damage scales with proximity - closer = more damage
                        const intensity = 1 - (dist / thornRange);
                        if (Math.random() < dt * 4 * intensity) {
                            const dmg = Math.max(1, Math.floor(intensity * 8));
                            socket.emit('playerHit', { targetId: id, damage: dmg, attackerId: myId });
                            spawnParticles(
                                state.me.x + (Math.random()-0.5)*thornRange,
                                state.me.y + (Math.random()-0.5)*thornRange,
                                2, '#65a30d'
                            );
                        }
                        // Slow effect: push players that are very close back slightly
                        if (dist < 80 && Math.random() < dt * 3) {
                            socket.emit('playerHit', { targetId: id, damage: 3, attackerId: myId });
                        }
                    }
                }
                // Thorn visual aura particles periodically
                if (Math.random() < dt * 6) {
                    const thornAngle = Math.random() * Math.PI * 2;
                    const thornDist = 60 + Math.random() * 100;
                    spawnParticles(
                        state.me.x + Math.cos(thornAngle) * thornDist,
                        state.me.y + Math.sin(thornAngle) * thornDist,
                        2, '#65a30d'
                    );
                }
            }
            if (state.me.currentPower === 'vampire') {
                for (let id in state.players) {
                    const p = state.players[id];
                    const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                    if (dist < 80 && Math.random() < 0.05) {
                        socket.emit('playerHit', { targetId: id, damage: 3, attackerId: myId });
                        state.me.hp = Math.min(100, state.me.hp + 3);
                        spawnParticles(state.me.x, state.me.y, 3, '#7f1d1d');
                    }
                }
            }
            if (state.omegaTimer > 0) {
                state.omegaTimer -= dt;
                if (state.omegaTimer <= 0) {
                    const wasMirror = state.mirrorActive;
                    state.mirrorActive = false; state.timestopActive = false;
                    showToast(wasMirror ? 'üõ°Ô∏è Mirror Shield ended!' : 'Omega ended!', 'warning'); updateScreenEffects();
                }
            }
            if (state.cloneTimer > 0) {
                state.cloneTimer -= dt; updateCloneUI();
                if (state.cloneTimer <= 0) state.clones = [];
            }

            for (let ownerId in state.remoteClones) {
                const clones = state.remoteClones[ownerId];
                const owner = state.players[ownerId];
                if (!owner) { delete state.remoteClones[ownerId]; continue; }
                for (let i = clones.length - 1; i >= 0; i--) {
                    const clone = clones[i];
                    clone.timer -= dt;
                    const orbitDist = 80;
                    const targetX = owner.x - Math.cos(owner.angle + clone.offsetAngle) * orbitDist;
                    const targetY = owner.y - Math.sin(owner.angle + clone.offsetAngle) * orbitDist;
                    clone.x += (targetX - clone.x) * 0.2;
                    clone.y += (targetY - clone.y) * 0.2;
                    clone.angle = owner.angle;
                    clone.name = owner.name; clone.hp = 50; clone.kills = 0; clone.currentPower = 'clone';
                    if (clone.timer <= 0) clones.splice(i, 1);
                }
                if (clones.length === 0) delete state.remoteClones[ownerId];
            }

            for (let i = state.meteors.length - 1; i >= 0; i--) {
                const m = state.meteors[i];
                m.y += m.speed * dt;
                if (m.y >= m.targetY) {
                    state.explosions.push({ x: m.x, y: m.targetY, radius: 20, maxRadius: 100, life: 0.5, color: '#ff4500' });
                    spawnParticles(m.x, m.targetY, 20, '#ff4500');
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((m.x - p.x)**2 + (m.targetY - p.y)**2) < 100) {
                            // FIXED: Don't send hit if meteor hits self (checking if hit player is the caster)
                            if (id !== myId) {
                                socket.emit('playerHit', { targetId: id, damage: 40, attackerId: myId });
                            } else {
                                // Self-damage from own meteor (no kill credit should be assigned)
                                socket.emit('playerHit', { targetId: myId, damage: 40, attackerId: null });
                            }
                        }
                    }
                    state.meteors.splice(i, 1);
                }
            }

            state.mouse.worldX = state.mouse.x + state.camera.x;
            state.mouse.worldY = state.mouse.y + state.camera.y;
            const dx = state.mouse.worldX - state.me.x;
            const dy = state.mouse.worldY - state.me.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            state.me.angle = Math.atan2(dy, dx);

            let canMove = state.me.frozen <= 0;
            if (dist > 10 && canMove) {
                let speed = 2.5;
                if (state.me.currentPower === 'speed' && state.speedActive) speed = 5.5;
                if (state.me.currentPower === 'berserker' && state.berserkerActive) speed = 6;
                if (state.me.currentPower === 'tank') speed = 1.5;
                state.me.x += (dx / dist) * speed;
                state.me.y += (dy / dist) * speed;
                state.me.x = Math.max(25, Math.min(CONFIG.map.width - 25, state.me.x));
                state.me.y = Math.max(25, Math.min(CONFIG.map.height - 25, state.me.y));
            }

            state.clones.forEach((clone, idx) => {
                const followDist = 80 + idx * 50;
                const angleOffset = (idx % 2 === 0 ? 1 : -1) * (Math.PI / 4);
                const targetX = state.me.x - Math.cos(state.me.angle + angleOffset) * followDist;
                const targetY = state.me.y - Math.sin(state.me.angle + angleOffset) * followDist;
                clone.x += (targetX - clone.x) * 0.1;
                clone.y += (targetY - clone.y) * 0.1;
                clone.angle = state.me.angle;
                if (Math.random() < 0.03) {
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((clone.x - p.x)**2 + (clone.y - p.y)**2) < 300) {
                            clone.angle = Math.atan2(p.y - clone.y, p.x - clone.x);
                            shootProjectile(clone.x, clone.y, clone.angle, 'basic', 10);
                            break;
                        }
                    }
                }
            });

            for (let id in state.powerups) {
                const p = state.powerups[id];
                if (!p || !p.type || !ALL_POWERS[p.type]) { delete state.powerups[id]; continue; }
                let collectDist = 40;
                if (state.me.currentPower === 'magnet') collectDist = 150;
                const distP = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                if (state.me.currentPower === 'magnet' && distP < 200 && distP > 40) {
                    const pullAngle = Math.atan2(state.me.y - p.y, state.me.x - p.x);
                    p.x += Math.cos(pullAngle) * 3; p.y += Math.sin(pullAngle) * 3;
                }
                // Simulate magnet pull from remote players so all screens look identical
                for (let pid in state.players) {
                    const mp = state.players[pid];
                    if (mp.currentPower !== 'magnet') continue;
                    const mpDist = Math.sqrt((mp.x - p.x)**2 + (mp.y - p.y)**2);
                    if (mpDist < 200 && mpDist > 40) {
                        const mpa = Math.atan2(mp.y - p.y, mp.x - p.x);
                        p.x += Math.cos(mpa) * 3; p.y += Math.sin(mpa) * 3;
                    }
                }
                if (distP < 40) {
                    socket.emit('powerupTaken', { id });
                    state.me.currentPower = p.type;
                    state.me.isOmegaPower = !!(OMEGA_POWER[p.type] || ADMIN_POWERS[p.type]);
                    state.me.isMythicPower = !!(POWERS[p.type] && POWERS[p.type].rarity === 'mythic');
                    state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
                    updatePowerUI(p.type); broadcastState();
                    spawnParticles(p.x, p.y, 15, ALL_POWERS[p.type].color);
                    delete state.powerups[id];
                }
            }

            for (let id in state.projectiles) {
                const proj = state.projectiles[id];
                if (proj.localUpdate) {
                    proj.x += Math.cos(proj.angle) * proj.speed * dt;
                    proj.y += Math.sin(proj.angle) * proj.speed * dt;
                    proj.life -= dt;
                    if (proj.owner === myId && !proj.isRemote) {
                        for (let pid in state.players) {
                            const p = state.players[pid];
                            const hitDist = Math.sqrt((p.x - proj.x)**2 + (p.y - proj.y)**2);
                            const hitKey = `${proj.id}_${pid}`;
                            if (hitDist < 28 && !state.hitCooldowns[hitKey]) {
                                state.hitCooldowns[hitKey] = Date.now();
                                let damage = proj.damage || 20;
                                if (state.me.currentPower === 'rage') damage *= 2;
                                socket.emit('playerHit', { targetId: pid, damage, attackerId: myId });
                                spawnParticles(p.x, p.y, 8, '#ef4444');
                                spawnDamageNumber(p.x, p.y, damage, 'damage');
                                if (state.me.currentPower === 'vampire') {
                                    state.me.hp = Math.min(100, state.me.hp + Math.floor(damage * 0.3));
                                }
                                // Explosive: big explosion dealing half damage to all nearby
                                if (proj.type === 'explosive') {
                                    const splashDmg = Math.floor(damage * 0.85);
                                    state.explosions.push({ x: proj.x, y: proj.y, radius: 20, maxRadius: 180, life: 0.8, color: '#f87171' });
                                    for (let i = 0; i < 40; i++) spawnParticles(proj.x, proj.y, 1, ['#f87171','#f59e0b','#ef4444'][Math.floor(Math.random()*3)]);
                                    for (let splashId in state.players) {
                                        if (splashId === pid) continue;
                                        const sp = state.players[splashId];
                                        if (Math.sqrt((proj.x-sp.x)**2+(proj.y-sp.y)**2) < 180) {
                                            socket.emit('playerHit', { targetId: splashId, damage: splashDmg, attackerId: myId });
                                        }
                                    }
                                    emitAbilityEffect('shockwave', proj.x, proj.y);
                                    delete state.projectiles[id]; break;
                                }
                                if (!proj.pierce) { delete state.projectiles[id]; break; }
                            }
                        }
                    }
                    if (proj.isRemote && proj.owner !== myId) {
                        const hitDist = Math.sqrt((state.me.x - proj.x)**2 + (state.me.y - proj.y)**2);
                        const hitKey = `${proj.id}_me`;
                        if (hitDist < 28 && !state.hitCooldowns[hitKey] && !state.adminGodMode && !state.isDead) {
                            state.hitCooldowns[hitKey] = Date.now();
                            if (state.me.currentPower === 'phase' && state.phaseActive) {
                            } else if (state.mirrorActive) {
                                socket.emit('playerHit', { targetId: proj.owner, damage: proj.damage, attackerId: myId });
                                spawnParticles(state.me.x, state.me.y, 10, '#c0c0c0');
                            } else {
                                let damage = proj.damage || 20;
                                if (state.me.currentPower === 'shield') damage = Math.floor(damage * 0.5);
                                if (state.me.currentPower === 'tank') damage = Math.floor(damage * 0.25);
                                state.me.hp -= damage;
                                spawnDamageNumber(state.me.x, state.me.y, damage, 'damage');
                                spawnParticles(state.me.x, state.me.y, 10, '#ef4444');
                                if (state.me.currentPower === 'thorns') {
                                    socket.emit('playerHit', { targetId: proj.owner, damage: Math.floor(damage * 0.3), attackerId: myId });
                                }
                                if (state.me.hp <= 0 && !state.isDead) {
                                    state.isDead = true;
                                    socket.emit('playerDied', { victimId: myId, killerId: proj.owner });
                                }
                            }
                            if (!proj.pierce) delete state.projectiles[id];
                        }
                    }
                    if (proj.life <= 0 || proj.x < 0 || proj.x > CONFIG.map.width || proj.y < 0 || proj.y > CONFIG.map.height) {
                        delete state.projectiles[id];
                    }
                }
            }

            const now = Date.now();
            for (let key in state.hitCooldowns) {
                if (now - state.hitCooldowns[key] > 500) delete state.hitCooldowns[key];
            }
            broadcastState();
            state.camera.x += (state.me.x - canvas.width / 2 - state.camera.x) * 0.1;
            state.camera.y += (state.me.y - canvas.height / 2 - state.camera.y) * 0.1;

            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.life -= dt * 2; p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98;
                if (p.life <= 0) state.particles.splice(i, 1);
            }
            for (let i = state.explosions.length - 1; i >= 0; i--) {
                const e = state.explosions[i];
                e.life -= dt * 2; e.radius += dt * 200;
                if (e.life <= 0) state.explosions.splice(i, 1);
            }
            // Update timebomb timers
            for (let i = state.timebombs.length - 1; i >= 0; i--) {
                state.timebombs[i].timer -= dt;
                if (state.timebombs[i].timer <= -1) state.timebombs.splice(i, 1);
            }
            for (let id in state.players) {
                const p = state.players[id];
                if (p.targetX !== undefined && !state.timestopActive) {
                    p.x += (p.targetX - p.x) * 0.2; p.y += (p.targetY - p.y) * 0.2;
                }
            }
            if (state.me.recoil > 0) state.me.recoil -= dt * 30;
            if (Math.random() < 0.1) updateLeaderboard();
            
            // Baby update
            if (state.baby) {
                state.baby.targetX = state.mouse.worldX;
                state.baby.targetY = state.mouse.worldY;
                const bDx = state.baby.targetX - state.baby.x;
                const bDy = state.baby.targetY - state.baby.y;
                const bDist = Math.sqrt(bDx*bDx + bDy*bDy);
                if (bDist > 15) {
                    state.baby.x += (bDx/bDist) * 3.5;
                    state.baby.y += (bDy/bDist) * 3.5;
                    state.baby.angle = Math.atan2(bDy, bDx);
                }
                // Baby shoots at nearest enemy
                state.babyShootCooldown -= dt;
                if (state.babyShootCooldown <= 0) {
                    state.babyShootCooldown = 0.6;
                    let closest = null, closestDist = 200;
                    for (let id in state.players) {
                        const p = state.players[id];
                        const d = Math.sqrt((state.baby.x-p.x)**2+(state.baby.y-p.y)**2);
                        if (d < closestDist) { closestDist = d; closest = { id, ...p }; }
                    }
                    if (closest) {
                        const shootAngle = Math.atan2(closest.y - state.baby.y, closest.x - state.baby.x);
                        const bProjId = 'baby_' + (projectileIdCounter++);
                        state.projectiles[bProjId] = {
                            id: bProjId, x: state.baby.x, y: state.baby.y, angle: shootAngle,
                            type: 'basic', damage: 8, speed: 500, owner: myId,
                            color: '#ff69b4', life: 2, localUpdate: true, isRemote: false, isBaby: true
                        };
                        socket.emit('shoot', { x: state.baby.x, y: state.baby.y, angle: shootAngle, type: 'basic', damage: 8, speed: 500, color: '#ff69b4' });
                    }
                }
                // Baby can be killed by others being close
                for (let id in state.players) {
                    const p = state.players[id];
                    if (Math.sqrt((state.baby.x-p.x)**2+(state.baby.y-p.y)**2) < 30) {
                        if (Math.random() < dt * 2) {
                            state.baby.hp -= 5;
                            spawnParticles(state.baby.x, state.baby.y, 5, '#ef4444');
                        }
                    }
                }
                if (state.baby.hp <= 0) {
                    state.explosions.push({ x: state.baby.x, y: state.baby.y, radius: 20, maxRadius: 100, life: 0.6, color: '#ff69b4' });
                    spawnParticles(state.baby.x, state.baby.y, 30, '#ff69b4');
                    socket.emit('abilityUsed', { type: 'babydied', x: state.baby.x, y: state.baby.y, id: myId });
                    state.baby = null;
                    document.getElementById('baby-controls').classList.remove('visible');
                    showToast('Baby was killed!', 'error');
                } else {
                    const hpPct = state.baby.hp / 50;
                    document.getElementById('baby-hp-fill').style.width = (hpPct*100)+'%';
                    document.getElementById('baby-hp-text').textContent = state.baby.hp;
                    // Broadcast baby position to all other players (~10x per second)
                    if (!state.babyBroadcastTimer) state.babyBroadcastTimer = 0;
                    state.babyBroadcastTimer -= dt;
                    if (state.babyBroadcastTimer <= 0) {
                        state.babyBroadcastTimer = 0.1;
                        socket.emit('abilityUsed', { type: 'babypos', x: state.baby.x, y: state.baby.y, id: myId, angle: state.baby.angle, hp: state.baby.hp });
                    }
                }
            }
        }

        function shootProjectile(x, y, angle, type, damage = 20) {
            const id = 'local_' + (projectileIdCounter++);
            const info = ALL_POWERS[type] || { color: '#00f2fe' };
            let speed = 600;
            if (type === 'sniper') { speed = 1200; damage = 60; }
            if (type === 'minigun') { speed = 700; }
            if (type === 'laser') damage = 15;
            state.projectiles[id] = {
                id, x, y, angle, type, damage, speed, owner: myId,
                color: info.color || '#00f2fe', pierce: type === 'laser',
                life: 3, localUpdate: true, isRemote: false
            };
            spawnParticles(x, y, 5, info.color || '#00f2fe');
            if (socket) {
                socket.emit('shoot', { x, y, angle, type, damage, speed, color: info.color || '#00f2fe' });
            }
        }

        function render() {
            ctx.fillStyle = CONFIG.colors.grid;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-state.camera.x, -state.camera.y);
            drawGrid();
            for (let e of state.explosions) {
                ctx.globalAlpha = e.life * 0.6; ctx.fillStyle = e.color;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1;
            for (let m of state.meteors) {
                ctx.fillStyle = '#ff4500'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff4500';
                ctx.beginPath(); ctx.arc(m.x, m.y, 15, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            }
            for (let id in state.powerups) {
                const p = state.powerups[id];
                if (p && p.type && ALL_POWERS[p.type]) drawPowerup(p);
            }
            // Draw active timebombs - same small pulsing indicator on all screens
            for (let bomb of state.timebombs) {
                if (bomb.timer <= 0) continue;
                const pulse = Math.sin(Date.now() / 120) * 0.4 + 0.6;
                const urgency = 1 - (bomb.timer / 2.0);
                ctx.save();
                ctx.globalAlpha = pulse;
                ctx.fillStyle = '#ff6b00'; ctx.shadowBlur = 12 + urgency * 20; ctx.shadowColor = '#ff6b00';
                ctx.beginPath(); ctx.arc(bomb.x, bomb.y, 8 + urgency * 6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 0.4 * pulse;
                ctx.strokeStyle = '#ff6b00'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(bomb.x, bomb.y, 18 + urgency * 10, 0, Math.PI * 2); ctx.stroke();
                ctx.shadowBlur = 0; ctx.restore();
                ctx.save();
                ctx.fillStyle = 'white'; ctx.font = 'bold 11px Outfit'; ctx.textAlign = 'center';
                ctx.shadowColor = '#ff6b00'; ctx.shadowBlur = 6;
                ctx.fillText(Math.ceil(bomb.timer) + 's', bomb.x, bomb.y - 22);
                ctx.restore();
            }
            for (let id in state.projectiles) {
                const p = state.projectiles[id];
                const projRadius = p.type === 'explosive' ? 12 : (p.type === 'minigun' ? 4 : 6);
                ctx.fillStyle = p.color || '#00f2fe'; ctx.shadowBlur = 8; ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath(); ctx.arc(p.x, p.y, projRadius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            }
            // Draw laser beams (visible to all)
            for (let i = state.laserBeams.length - 1; i >= 0; i--) {
                const lb = state.laserBeams[i];
                lb.life -= 0.04;
                if (lb.life <= 0) { state.laserBeams.splice(i, 1); continue; }
                ctx.save();
                ctx.globalAlpha = lb.life;
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 8 * lb.life;
                ctx.shadowBlur = 20; ctx.shadowColor = '#ef4444';
                ctx.beginPath();
                ctx.moveTo(lb.x1, lb.y1);
                ctx.lineTo(lb.x2, lb.y2);
                ctx.stroke();
                ctx.lineWidth = 3 * lb.life; ctx.strokeStyle = '#ffaaaa';
                ctx.beginPath(); ctx.moveTo(lb.x1, lb.y1); ctx.lineTo(lb.x2, lb.y2); ctx.stroke();
                ctx.shadowBlur = 0; ctx.restore();
            }
            // Draw rocket trails (visible to all)
            for (let i = state.rocketTrails.length - 1; i >= 0; i--) {
                const rt = state.rocketTrails[i];
                rt.life -= 0.05;
                if (rt.life <= 0) { state.rocketTrails.splice(i, 1); continue; }
                ctx.save();
                ctx.globalAlpha = rt.life * 0.8;
                ctx.fillStyle = '#fb923c'; ctx.shadowBlur = 12; ctx.shadowColor = '#fb923c';
                ctx.beginPath(); ctx.arc(rt.x, rt.y, 8 * rt.life, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                ctx.restore();
            }
            for (let clone of state.clones) drawPlayer(clone, false, true);
            for (let ownerId in state.remoteClones) {
                for (let clone of state.remoteClones[ownerId]) drawPlayer(clone, false, true);
            }
            for (let id in state.players) {
                if (state.players[id].hp > 0) drawPlayer(state.players[id], false, false);
            }
            if (state.me && !state.isDead) drawPlayer(state.me, true, false);
            // Draw baby
            if (state.baby) {
                ctx.save();
                ctx.translate(state.baby.x, state.baby.y);
                ctx.rotate(state.baby.angle);
                ctx.fillStyle = '#ff69b4'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff69b4';
                ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath(); ctx.arc(5, -3, 2, 0, Math.PI * 2); ctx.arc(5, 3, 2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                // Baby HP bar and label
                ctx.save();
                ctx.translate(state.baby.x, state.baby.y);
                ctx.fillStyle = 'white'; ctx.font = 'bold 9px Outfit'; ctx.textAlign = 'center';
                ctx.shadowColor = 'black'; ctx.shadowBlur = 3;
                ctx.fillText('BABY', 0, -22);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath(); ctx.roundRect(-15, -18, 30, 4, 2); ctx.fill();
                ctx.fillStyle = '#ff69b4';
                ctx.beginPath(); ctx.roundRect(-15, -18, 30*(state.baby.hp/50), 4, 2); ctx.fill();
                ctx.restore();
            }
            // Draw remote babies (from other players)
            for (let ownerId in state.remoteBabies) {
                const rb = state.remoteBabies[ownerId];
                if (!rb) continue;
                ctx.save();
                ctx.translate(rb.x, rb.y);
                ctx.rotate(rb.angle || 0);
                ctx.fillStyle = '#ff69b4'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff69b4';
                ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath(); ctx.arc(5, -3, 2, 0, Math.PI * 2); ctx.arc(5, 3, 2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.translate(rb.x, rb.y);
                ctx.fillStyle = 'white'; ctx.font = 'bold 9px Outfit'; ctx.textAlign = 'center';
                ctx.shadowColor = 'black'; ctx.shadowBlur = 3;
                ctx.fillText('BABY', 0, -22);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath(); ctx.roundRect(-15, -18, 30, 4, 2); ctx.fill();
                ctx.fillStyle = '#ff69b4';
                ctx.beginPath(); ctx.roundRect(-15, -18, 30 * ((rb.hp || 50) / 50), 4, 2); ctx.fill();
                ctx.restore();
            }
            for (let p of state.particles) {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Draw all Bosses
            for (const bossId in state.bosses) {
                const boss = state.bosses[bossId];
                if (!boss) continue;
                // Smooth movement
                if (boss.targetX !== undefined) {
                    boss.x = (boss.x || boss.targetX) + ((boss.targetX - (boss.x || boss.targetX)) * 0.15);
                    boss.y = (boss.y || boss.targetY) + ((boss.targetY - (boss.y || boss.targetY)) * 0.15);
                }
                const bx = boss.x, by = boss.y;
                const bHpPct = Math.max(0, (boss.hp || 0) / (boss.maxHp || 1000));
                ctx.save();
                ctx.translate(bx, by);
                const bAura = Math.sin(Date.now() / 150) * 15 + 50;
                const bGrad = ctx.createRadialGradient(0, 0, 20, 0, 0, bAura + 30);
                bGrad.addColorStop(0, 'rgba(255,0,0,0.4)');
                bGrad.addColorStop(1, 'rgba(80,0,0,0)');
                ctx.fillStyle = bGrad;
                ctx.beginPath(); ctx.arc(0, 0, bAura + 30, 0, Math.PI * 2); ctx.fill();
                ctx.rotate(boss.angle || 0);
                ctx.fillStyle = '#b91c1c'; ctx.shadowBlur = 30; ctx.shadowColor = '#ff0000';
                ctx.beginPath(); ctx.arc(0, 0, 42, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                for (let i = 0; i < 8; i++) {
                    const sa = (i / 8) * Math.PI * 2 + Date.now() / 500;
                    ctx.fillStyle = '#7f1d1d';
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(sa) * 40, Math.sin(sa) * 40);
                    ctx.lineTo(Math.cos(sa + 0.2) * 62, Math.sin(sa + 0.2) * 62);
                    ctx.lineTo(Math.cos(sa - 0.2) * 62, Math.sin(sa - 0.2) * 62);
                    ctx.fill();
                }
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath(); ctx.arc(14, -12, 8, 0, Math.PI * 2); ctx.arc(14, 12, 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(17, -12, 4, 0, Math.PI * 2); ctx.arc(17, 12, 4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.translate(bx, by);
                ctx.fillStyle = '#ff4444'; ctx.font = 'bold 18px Outfit'; ctx.textAlign = 'center';
                ctx.shadowColor = '#000'; ctx.shadowBlur = 5;
                ctx.fillText(`üíÄ BOSS ${boss.label || ''}`, 0, -70);
                ctx.font = 'bold 13px Outfit'; ctx.fillStyle = '#fbbf24';
                ctx.fillText(`${Math.round(boss.hp || 0)} / ${boss.maxHp || 1000} HP`, 0, -53);
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath(); ctx.roundRect(-50, -45, 100, 8, 4); ctx.fill();
                ctx.fillStyle = bHpPct > 0.5 ? '#ef4444' : (bHpPct > 0.25 ? '#f59e0b' : '#dc2626');
                ctx.beginPath(); ctx.roundRect(-50, -45, 100 * bHpPct, 8, 4); ctx.fill();
                ctx.restore();
                // Boss hit detection for projectiles
                for (let id in state.projectiles) {
                    const proj = state.projectiles[id];
                    if (proj.owner !== myId || proj.isRemote) continue;
                    const hitDist = Math.sqrt((bx - proj.x) ** 2 + (by - proj.y) ** 2);
                    const hitKey = `boss_${bossId}_${proj.id}`;
                    if (hitDist < 50 && !state.hitCooldowns[hitKey]) {
                        state.hitCooldowns[hitKey] = Date.now();
                        socket.emit('bossHit', { bossId, damage: proj.damage || 20, attackerId: myId });
                        spawnParticles(bx, by, 10, '#ff4444');
                        spawnDamageNumber(bx, by, proj.damage || 20, 'damage');
                        if (!proj.pierce) delete state.projectiles[id];
                    }
                }
            }

            ctx.restore();
        }

        function drawGrid() {
            const gridSize = 100;
            const startX = Math.floor(state.camera.x / gridSize) * gridSize;
            const startY = Math.floor(state.camera.y / gridSize) * gridSize;
            ctx.strokeStyle = CONFIG.colors.gridLine; ctx.lineWidth = 2; ctx.beginPath();
            for (let x = startX; x < startX + canvas.width + gridSize; x += gridSize) {
                if (x >= 0 && x <= CONFIG.map.width) {
                    ctx.moveTo(x, Math.max(0, startY));
                    ctx.lineTo(x, Math.min(CONFIG.map.height, startY + canvas.height + gridSize));
                }
            }
            for (let y = startY; y < startY + canvas.height + gridSize; y += gridSize) {
                if (y >= 0 && y <= CONFIG.map.height) {
                    ctx.moveTo(Math.max(0, startX), y);
                    ctx.lineTo(Math.min(CONFIG.map.width, startX + canvas.width + gridSize), y);
                }
            }
            ctx.stroke();
            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, CONFIG.map.width, CONFIG.map.height);
        }

        function drawPlayer(p, isMe, isClone) {
            if (!p || p.hp <= 0) return;
            if (isClone) ctx.globalAlpha = 0.7;
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.save();
            ctx.fillStyle = isClone ? '#14b8a6' : 'white';
            ctx.font = 'bold 14px Outfit'; ctx.textAlign = 'center';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 4;

            // Draw OWNER crown tag above name for admin
            const isOwnerPlayer = p.isOwner || (isMe && isAdmin);
            if (isOwnerPlayer) {
                // Crown glow
                ctx.save();
                const ownerPulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                ctx.shadowBlur = 12; ctx.shadowColor = '#ffd700';
                ctx.fillStyle = `rgba(255,215,0,${ownerPulse})`;
                ctx.font = 'bold 10px Outfit';
                ctx.fillText('üëë OWNER', 0, -68);
                ctx.restore();
            }

            ctx.fillText(p.name || 'Player', 0, -50);
            const kills = isMe ? state.kills : (p.kills || 0);
            ctx.fillStyle = kills >= 10 ? '#ffd700' : 'rgba(255,255,255,0.7)';
            ctx.font = 'bold 11px Outfit';
            ctx.fillText(`${kills} kills`, 0, -38);
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.roundRect(-25, -30, 50, 6, 3); ctx.fill();
            const hpPct = Math.max(0, (p.hp || 100) / 100);
            ctx.fillStyle = hpPct > 0.5 ? '#10b981' : '#ef4444';
            ctx.beginPath(); ctx.roundRect(-25, -30, 50 * hpPct, 6, 3); ctx.fill();
            ctx.restore();
            ctx.rotate(p.angle || 0);
            const power = p.currentPower;
            const powerDef = ALL_POWERS[power];
            if (power === 'shield') {
                ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 3;
                ctx.shadowBlur = 15; ctx.shadowColor = '#3b82f6';
                ctx.beginPath(); ctx.arc(0, 0, 36, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0;
            }
            if (power === 'tank') {
                ctx.strokeStyle = '#374151'; ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(0, 0, 34, 0, Math.PI * 2); ctx.stroke();
            }
            if (power === 'phase' && (isMe ? state.phaseActive : p.phaseActive)) {
                ctx.strokeStyle = 'rgba(167,139,250,0.6)'; ctx.lineWidth = 2; ctx.setLineDash([8,4]);
                ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]);
            }
            if (power === 'berserker' && (isMe ? state.berserkerActive : p.berserkerActive)) {
                for (let i = 0; i < 8; i++) {
                    const ang = (i / 8) * Math.PI * 2 + Date.now() / 200;
                    ctx.fillStyle = `rgba(220,38,38,${0.5 + Math.random() * 0.3})`;
                    ctx.beginPath(); ctx.arc(Math.cos(ang) * 30, Math.sin(ang) * 30, 4, 0, Math.PI * 2); ctx.fill();
                }
            }
            if (power === 'speed' && (isMe ? state.speedActive : p.speedActive)) {
                ctx.strokeStyle = 'rgba(239,68,68,0.6)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI * 2); ctx.stroke();
            }
            if (power === 'vampire') {
                const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.5;
                ctx.strokeStyle = `rgba(127,29,29,${pulse})`; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI * 2); ctx.stroke();
            }
            if (power === 'thorns') {
                // Draw thorn spike aura around player
                const now = Date.now();
                for (let i = 0; i < 12; i++) {
                    const spikeAngle = (i / 12) * Math.PI * 2 + now / 1500;
                    const spikeLen = 22 + Math.sin(now / 300 + i) * 6;
                    ctx.strokeStyle = 'rgba(101,163,13,0.75)'; ctx.lineWidth = 2;
                    ctx.shadowBlur = 6; ctx.shadowColor = '#65a30d';
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(spikeAngle) * 24, Math.sin(spikeAngle) * 24);
                    ctx.lineTo(Math.cos(spikeAngle) * (24 + spikeLen), Math.sin(spikeAngle) * (24 + spikeLen));
                    ctx.stroke(); ctx.shadowBlur = 0;
                }
                ctx.strokeStyle = 'rgba(101,163,13,0.4)'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(0, 0, 180, 0, Math.PI * 2); ctx.stroke();
            }
            if (power === 'poison') {
                const pulseP = Math.sin(Date.now() / 400) * 0.3 + 0.5;
                ctx.strokeStyle = `rgba(132,204,22,${pulseP})`; ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.stroke();
                ctx.setLineDash([]);
            }
            if (power === 'phoenix') {
                const pp = Math.sin(Date.now() / 180) * 0.4 + 0.6;
                ctx.strokeStyle = `rgba(255,102,0,${pp})`; ctx.lineWidth = 3;
                ctx.shadowBlur = 20; ctx.shadowColor = '#ff6600';
                ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0;
                for (let i = 0; i < 6; i++) {
                    const fa = (i / 6) * Math.PI * 2 + Date.now() / 600;
                    ctx.fillStyle = `rgba(255,${100 + Math.floor(Math.sin(Date.now()/300+i)*80)},0,0.5)`;
                    ctx.beginPath(); ctx.arc(Math.cos(fa)*30, Math.sin(fa)*30, 5, 0, Math.PI*2); ctx.fill();
                }
            }
            if (power === 'soulsteal') {
                const sp = Math.sin(Date.now() / 220) * 0.3 + 0.6;
                ctx.strokeStyle = `rgba(136,0,255,${sp})`; ctx.lineWidth = 3;
                ctx.shadowBlur = 20; ctx.shadowColor = '#8800ff';
                ctx.beginPath(); ctx.arc(0, 0, 37, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0;
            }
            if (isMe && state.mirrorActive || (!isMe && p.mirrorActive)) {
                ctx.strokeStyle = '#c0c0c0'; ctx.lineWidth = 3;
                ctx.shadowBlur = 20; ctx.shadowColor = '#c0c0c0';
                ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0;
            }
            const recoil = (isMe && state.me?.recoil) ? state.me.recoil : 0;
            ctx.fillStyle = '#94a3b8';
            ctx.beginPath(); ctx.arc(16 - recoil, -15, 8, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(16 - recoil, 15, 8, 0, Math.PI * 2); ctx.fill();
            let bodyColor = powerDef ? powerDef.color : (isMe ? '#00f2fe' : '#ef4444');
            if (isClone) bodyColor = '#14b8a6';
            if (isMe && state.adminGodMode) bodyColor = '#ff00ff';
            ctx.fillStyle = bodyColor;
            if (isMe || isClone) { ctx.shadowBlur = 15; ctx.shadowColor = bodyColor; }
            ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath(); ctx.arc(10, -7, 4, 0, Math.PI * 2); ctx.arc(10, 7, 4, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function drawPowerup(p) {
            const info = ALL_POWERS[p.type];
            if (!info) return;
            const bounce = Math.sin(Date.now() / 250) * 4;
            const rarityColor = RARITY_COLORS[info.rarity] || '#9ca3af';
            ctx.save();
            ctx.translate(p.x, p.y + bounce);
            if (info.rarity === 'omega') {
                const pulse = Math.sin(Date.now() / 150) * 10 + 30;
                const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, pulse);
                gradient.addColorStop(0, 'rgba(255,215,0,0.4)');
                gradient.addColorStop(1, 'rgba(255,107,0,0)');
                ctx.fillStyle = gradient;
                ctx.beginPath(); ctx.arc(0, 0, pulse, 0, Math.PI * 2); ctx.fill();
            }
            if (info.rarity === 'mythic') {
                const pulse = Math.sin(Date.now() / 120) * 12 + 32;
                const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, pulse);
                gradient.addColorStop(0, 'rgba(255,0,204,0.5)');
                gradient.addColorStop(1, 'rgba(51,0,255,0)');
                ctx.fillStyle = gradient;
                ctx.beginPath(); ctx.arc(0, 0, pulse, 0, Math.PI * 2); ctx.fill();
            }
            ctx.shadowBlur = 20; ctx.shadowColor = rarityColor;
            ctx.strokeStyle = rarityColor; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = info.color;
            ctx.beginPath(); ctx.arc(0, 0, 16, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            ctx.fillStyle = 'white'; ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(info.name.charAt(0), 0, 0);
            ctx.restore();
        }

        function spawnParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                state.particles.push({
                    x, y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12,
                    life: 1.0, size: Math.random() * 4 + 2, color
                });
            }
        }

        function spawnDamageNumber(x, y, damage, type = 'damage') {
            const dmgEl = document.createElement('div');
            dmgEl.className = `dmg-num ${type}`;
            dmgEl.textContent = type === 'heal' ? `+${damage}` : `-${damage}`;
            dmgEl.style.left = (x - state.camera.x) + 'px';
            dmgEl.style.top = (y - state.camera.y - 50) + 'px';
            document.getElementById('damage-numbers').appendChild(dmgEl);
            setTimeout(() => dmgEl.remove(), 1000);
        }

        function updatePowerUI(type) {
            const slot = document.getElementById('power-slot');
            const badge = document.getElementById('power-type-badge');
            const cx = document.getElementById('power-icon-canvas').getContext('2d');
            cx.clearRect(0, 0, 60, 60);
            if (!type || !ALL_POWERS[type]) {
                slot.classList.remove('active', 'speed-active', 'omega-active');
                badge.style.display = 'none';
                document.getElementById('power-hint-text').textContent = 'No Power';
                return;
            }
            const info = ALL_POWERS[type];
            slot.classList.add('active');
            slot.style.borderColor = info.color;
            slot.classList.toggle('omega-active', info.rarity === 'omega' || info.rarity === 'admin' || info.rarity === 'mythic');
            badge.style.display = 'block';
            badge.textContent = info.type === 'admin' ? 'admin' : info.rarity;
            badge.style.color = RARITY_COLORS[info.rarity];
            badge.classList.toggle('omega', info.rarity === 'omega' || info.rarity === 'admin' || info.rarity === 'mythic');
            document.getElementById('power-hint-text').textContent = `${info.name} (SPACE)`;
            cx.fillStyle = info.color; cx.shadowBlur = 10; cx.shadowColor = info.color;
            cx.beginPath(); cx.arc(25, 25, 20, 0, Math.PI * 2); cx.fill(); cx.shadowBlur = 0;
            cx.fillStyle = 'white'; cx.font = 'bold 14px Arial';
            cx.textAlign = 'center'; cx.textBaseline = 'middle';
            cx.fillText(info.name.charAt(0), 25, 25);
            showToast(`Got ${info.name}!`, info.rarity === 'omega' ? 'omega' : 'mythic');
        }

        function updateSpeedUI() {
            document.getElementById('power-slot').classList.toggle('speed-active', state.speedActive || state.phaseActive || state.berserkerActive);
        }

        function updateCloneUI() {
            const timer = document.getElementById('clone-timer');
            const fill = document.getElementById('clone-timer-fill');
            const label = document.getElementById('clone-timer-label');
            if (state.cloneTimer > 0) {
                timer.style.display = 'block'; label.style.display = 'block';
                fill.style.width = (state.cloneTimer / state.cloneMaxTime) * 100 + '%';
            } else { timer.style.display = 'none'; label.style.display = 'none'; }
        }

        function updateScreenEffects() {
            const effects = document.getElementById('screen-effects');
            effects.innerHTML = '';
            if (state.timestopActive) effects.innerHTML += '<div class="timestop-effect"></div>';
            if (state.mirrorActive) effects.innerHTML += '<div class="mirror-effect"></div>';
        }

        function updateLeaderboard() {
            const list = Object.values(state.players).map(p => ({ name: p.name, kills: p.kills || 0, id: p.id }));
            if (state.me) list.push({ name: state.me.name, kills: state.kills, id: myId });
            list.sort((a, b) => b.kills - a.kills);
            document.getElementById('lb-content').innerHTML = list.slice(0, 5).map(p => `
                <div class="lb-row ${p.id === myId ? 'me' : ''}">
                    <span>${escapeHtml(p.name)}</span><span>${p.kills}</span>
                </div>
            `).join('');
        }

        function escapeHtml(t) { return t ? t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;") : ''; }

        window.openModal = id => document.getElementById(id).style.display = 'flex';
        window.closeModal = id => document.getElementById(id).style.display = 'none';

        window.showToast = function(msg, type = 'info') {
            const el = document.createElement('div');
            el.className = `toast ${type}`;
            el.innerHTML = `<span>${msg}</span>`;
            document.getElementById('toast-container').appendChild(el);
            setTimeout(() => { el.classList.add('toast-exit'); setTimeout(() => el.remove(), 300); }, 2500);
        };

        window.addEventListener('mousemove', e => { state.mouse.x = e.clientX; state.mouse.y = e.clientY; });

        window.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                if (e.code === 'Enter' && e.target.id === 'chat-input') sendChat();
                return;
            }
            if (state.isDead) return;
            if (e.code === 'Space') { e.preventDefault(); tryPower(); }
            if (e.code === 'KeyD') { e.preventDefault(); tryDrop(); }
            if (e.code === 'KeyQ') { e.preventDefault(); tryOmegaPower(); }
            if (e.code === 'Enter') document.getElementById('chat-input').focus();
        });

        function tryDamageBoss(cx, cy, radius, damage) {
            for (const bossId in state.bosses) {
                const b = state.bosses[bossId];
                if (!b || !b.x) continue;
                const d = Math.sqrt((cx - b.x)**2 + (cy - b.y)**2);
                if (d < radius) {
                    socket.emit('bossHit', { bossId, damage, attackerId: myId });
                    spawnParticles(b.x, b.y, 15, '#ff4444');
                    spawnDamageNumber(b.x, b.y, damage, 'damage');
                }
            }
        }

        function tryOmegaPower() {
            if (!state.me || !state.omegaUnlocked || !state.omegaPower) {
                const threshold = state.nextOmegaThreshold || 10;
                showToast(`No Omega! Get ${threshold} kills.`, 'warning'); return;
            }
            const powerInfo = OMEGA_POWER[state.omegaPower];
            // Only meteor is the omega power for players now
            if (state.omegaPower === 'meteor') {
                const targetX = state.mouse.worldX;
                const targetY = state.mouse.worldY;
                for (let i = 0; i < 8; i++) {
                    const offsetX = (Math.random() - 0.5) * 300;
                    const offsetY = -400 - Math.random() * 200;
                    state.meteors.push({
                        x: targetX + offsetX, y: targetY + offsetY,
                        targetY: targetY, speed: 800
                    });
                }
                spawnParticles(targetX, targetY, 50, '#ff4500');
                emitAbilityEffect('meteor', targetX, targetY);
                showToast('METEOR STRIKE!', 'omega');
                tryDamageBoss(targetX, targetY, 500, 120);
                state.omegaUnlocked = false;
                state.omegaPower = null;
                // Advance the threshold by 10 so next omega requires 10 more kills
                state.nextOmegaThreshold = (state.nextOmegaThreshold || 10) + 10;
                updateKillCounter();
            }
        }

        function tryPower() {
            if (!state.me || !state.me.currentPower || !ALL_POWERS[state.me.currentPower]) {
                showToast('No power!', 'warning'); return;
            }
            const powerType = state.me.currentPower;
            const powerInfo = ALL_POWERS[powerType];
            if (powerInfo.type === 'passive') { showToast(`${powerInfo.name} is always active!`, 'mythic'); return; }
            if (powerInfo.type === 'toggle') {
                if (powerType === 'speed') state.speedActive = !state.speedActive;
                else if (powerType === 'phase') state.phaseActive = !state.phaseActive;
                else if (powerType === 'berserker') state.berserkerActive = !state.berserkerActive;
                updateSpeedUI(); broadcastState();
                showToast(`${powerInfo.name}: ${state.speedActive || state.phaseActive || state.berserkerActive ? 'ON' : 'OFF'}`, 'mythic');
                return;
            }
            if (powerInfo.type === 'shoot') {
                let cooldown = 0.15;
                if (powerType === 'minigun') cooldown = 0.03;
                if (powerType === 'sniper') cooldown = 0.8;
                if (powerType === 'voidbeam') cooldown = 0.3;
                if (state.adminInfinite) cooldown = 0.02;
                if (state.shootCooldown <= 0) {
                    const shootX = state.me.x + Math.cos(state.me.angle) * 25;
                    const shootY = state.me.y + Math.sin(state.me.angle) * 25;
                    let damage = 20;
                    if (powerType === 'sniper') damage = 60;
                    if (powerType === 'explosive') damage = 17; // half damage (ball), splash also does 17
                    if (powerType === 'voidbeam') damage = 50;
                    if (powerType === 'tripleshot') {
                        for (let i = -1; i <= 1; i++) shootProjectile(shootX, shootY, state.me.angle + i * 0.2, powerType, damage);
                    } else if (powerType === 'scatter') {
                        for (let i = 0; i < 8; i++) shootProjectile(state.me.x, state.me.y, (i / 8) * Math.PI * 2, powerType, 15);
                    } else if (powerType === 'voidbeam') {
                        for (let i = -2; i <= 2; i++) {
                            shootProjectile(shootX, shootY, state.me.angle + i * 0.05, powerType, damage);
                        }
                    } else { shootProjectile(shootX, shootY, state.me.angle, powerType, damage); }
                    state.me.recoil = powerType === 'sniper' ? 15 : 8;
                    state.shootCooldown = cooldown;
                }
                return;
            }
            let used = false;
            switch (powerType) {
                case 'dash':
                    const oldPos = { x: state.me.x, y: state.me.y };
                    state.me.x += Math.cos(state.me.angle) * 150;
                    state.me.y += Math.sin(state.me.angle) * 150;
                    state.me.x = Math.max(25, Math.min(CONFIG.map.width - 25, state.me.x));
                    state.me.y = Math.max(25, Math.min(CONFIG.map.height - 25, state.me.y));
                    spawnParticles(oldPos.x, oldPos.y, 15, '#f59e0b');
                    spawnParticles(state.me.x, state.me.y, 15, '#f59e0b');
                    emitAbilityEffect('dash', oldPos.x, oldPos.y);
                    emitAbilityEffect('dash', state.me.x, state.me.y);
                    showToast('Dashed!', 'mythic'); used = true; break;
                case 'teleport':
                    spawnParticles(state.me.x, state.me.y, 20, '#10b981');
                    emitAbilityEffect('teleport', state.me.x, state.me.y);
                    state.me.x = Math.max(50, Math.min(CONFIG.map.width - 50, state.mouse.worldX));
                    state.me.y = Math.max(50, Math.min(CONFIG.map.height - 50, state.mouse.worldY));
                    spawnParticles(state.me.x, state.me.y, 20, '#10b981');
                    emitAbilityEffect('teleport', state.me.x, state.me.y);
                    showToast('Warped!', 'mythic'); used = true; break;
                case 'poison':
                    // Poison aura: drains nearby enemies to ~5 HP over time but won't kill
                    const poisonX = state.me.x, poisonY = state.me.y;
                    state.explosions.push({ x: poisonX, y: poisonY, radius: 10, maxRadius: 180, life: 1.5, color: '#84cc16' });
                    spawnParticles(poisonX, poisonY, 40, '#84cc16');
                    socket.emit('abilityUsed', { type: 'poison', x: poisonX, y: poisonY, id: myId });
                    let poisonInterval = 0;
                    const poisonTick = setInterval(() => {
                        poisonInterval++;
                        for (let id in state.players) {
                            const p = state.players[id];
                            const dist = Math.sqrt((poisonX - p.x)**2 + (poisonY - p.y)**2);
                            if (dist < 200) {
                                const currentHp = p.hp || 100;
                                if (currentHp > 8) {
                                    socket.emit('playerHit', { targetId: id, damage: 6, attackerId: myId });
                                    spawnParticles(p.x, p.y, 3, '#84cc16');
                                }
                            }
                        }
                        // Self - apply poison tick visual
                        for (let i = 0; i < 5; i++) {
                            spawnParticles(
                                poisonX + (Math.random()-0.5)*180,
                                poisonY + (Math.random()-0.5)*180,
                                1, '#84cc16'
                            );
                        }
                        // Broadcast poison tick so others see the ongoing effect
                        socket.emit('abilityUsed', { type: 'poisontick', x: poisonX, y: poisonY, id: myId });
                        if (poisonInterval >= 8) clearInterval(poisonTick);
                        tryDamageBoss(poisonX, poisonY, 200, 6);
                    }, 300);
                    showToast('Poison Aura!', 'mythic'); used = true; break;
                case 'laser':
                    // Continuous laser beam for ~1 second ‚Äî fires in facing direction
                    const laserAngle = state.me.angle;
                    const laserStartX = state.me.x, laserStartY = state.me.y;
                    const laserEndX = laserStartX + Math.cos(laserAngle)*1200;
                    const laserEndY = laserStartY + Math.sin(laserAngle)*1200;
                    // Add beam to local render list
                    state.laserBeams.push({ x1: laserStartX, y1: laserStartY, x2: laserEndX, y2: laserEndY, life: 1 });
                    // Emit so others can see (must use 'abilityUsed' ‚Äî server re-broadcasts as 'abilityEffect')
                    socket.emit('abilityUsed', { type: 'laserbeam', x: laserStartX, y: laserStartY, x2: laserEndX, y2: laserEndY, id: myId });
                    let laserTick = 0, laserDmgDealt = {};
                    spawnParticles(laserStartX, laserStartY, 20, '#ef4444');
                    const laserFire = setInterval(() => {
                        laserTick++;
                        state.laserBeams.push({ x1: laserStartX, y1: laserStartY, x2: laserEndX, y2: laserEndY, life: 1 });
                        socket.emit('abilityUsed', { type: 'laserbeam', x: laserStartX, y: laserStartY, x2: laserEndX, y2: laserEndY, id: myId });
                        // Trace beam and hit players along it
                        for (let id in state.players) {
                            const p = state.players[id];
                            const dx = p.x - laserStartX, dy = p.y - laserStartY;
                            const t = dx * Math.cos(laserAngle) + dy * Math.sin(laserAngle);
                            if (t > 0 && t < 1200) {
                                const perpX = p.x - (laserStartX + Math.cos(laserAngle)*t);
                                const perpY = p.y - (laserStartY + Math.sin(laserAngle)*t);
                                const perpDist = Math.sqrt(perpX*perpX + perpY*perpY);
                                if (perpDist < 30) {
                                    const alreadyHit = laserDmgDealt[id] || 0;
                                    if (alreadyHit < 50) {
                                        const dmg = 8;
                                        socket.emit('playerHit', { targetId: id, damage: dmg, attackerId: myId });
                                        laserDmgDealt[id] = alreadyHit + dmg;
                                        spawnParticles(p.x, p.y, 5, '#ef4444');
                                    }
                                }
                            }
                        }
                        // Laser also damages boss along its path
                        tryDamageBoss(laserStartX + Math.cos(laserAngle)*600, laserStartY + Math.sin(laserAngle)*600, 500, 8);
                        if (laserTick >= 8) clearInterval(laserFire);
                    }, 125);
                    showToast('LASER BEAM!', 'mythic'); used = true; break;
                case 'rocket':
                    // Rocket form: dash in facing direction, leave fire trail damaging nearby enemies
                    const rocketAngle = state.me.angle;
                    const rocketStartX = state.me.x, rocketStartY = state.me.y;
                    emitAbilityEffect('dash', rocketStartX, rocketStartY);
                    let rocketStep = 0;
                    const rocketInterval = setInterval(() => {
                        rocketStep++;
                        const prevX = state.me.x, prevY = state.me.y;
                        state.me.x += Math.cos(rocketAngle) * 55;
                        state.me.y += Math.sin(rocketAngle) * 55;
                        state.me.x = Math.max(25, Math.min(CONFIG.map.width-25, state.me.x));
                        state.me.y = Math.max(25, Math.min(CONFIG.map.height-25, state.me.y));
                        // Fire trail local + remote (must use 'abilityUsed' ‚Äî server re-broadcasts as 'abilityEffect')
                        spawnParticles(prevX, prevY, 8, '#fb923c');
                        spawnParticles(prevX, prevY, 4, '#fbbf24');
                        state.rocketTrails.push({ x: prevX, y: prevY, life: 1 });
                        socket.emit('abilityUsed', { type: 'rockettrail', x: prevX, y: prevY, id: myId });
                        // Damage nearby enemies during dash
                        for (let id in state.players) {
                            const p = state.players[id];
                            const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                            if (dist < 100) socket.emit('playerHit', { targetId: id, damage: 15, attackerId: myId });
                        }
                        tryDamageBoss(state.me.x, state.me.y, 130, 15);
                        state.explosions.push({ x: prevX, y: prevY, radius: 10, maxRadius: 80, life: 0.4, color: '#fb923c' });
                        broadcastState();
                        if (rocketStep >= 6) {
                            clearInterval(rocketInterval);
                            spawnParticles(state.me.x, state.me.y, 30, '#fb923c');
                            state.rocketTrails.push({ x: state.me.x, y: state.me.y, life: 1.5 });
                            state.explosions.push({ x: state.me.x, y: state.me.y, radius: 20, maxRadius: 150, life: 0.7, color: '#fb923c' });
                            socket.emit('abilityUsed', { type: 'rockettrail', x: state.me.x, y: state.me.y, id: myId });
                        }
                    }, 60);
                    showToast('ROCKET LAUNCH!', 'mythic'); used = true; break;
                case 'clone':
                    for (let i = 0; i < 3; i++) {
                        const angleOffset = (i - 1) * (Math.PI / 3);
                        state.clones.push({
                            x: state.me.x - Math.cos(state.me.angle + angleOffset) * 60,
                            y: state.me.y - Math.sin(state.me.angle + angleOffset) * 60,
                            angle: state.me.angle, name: state.me.name, hp: 50, kills: 0, currentPower: 'clone'
                        });
                    }
                    state.cloneTimer = state.cloneMaxTime;
                    spawnParticles(state.me.x, state.me.y, 40, '#14b8a6');
                    emitAbilityEffect('clone', state.me.x, state.me.y);
                    showToast('Clones!', 'mythic'); updateCloneUI(); used = true; break;
                case 'heal':
                    state.me.hp = Math.min(100, state.me.hp + 50);
                    spawnParticles(state.me.x, state.me.y, 20, '#22c55e');
                    spawnDamageNumber(state.me.x, state.me.y, 50, 'heal');
                    emitAbilityEffect('heal', state.me.x, state.me.y);
                    showToast('Healed!', 'mythic'); used = true; break;
                case 'shockwave':
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2) < 200) {
                            socket.emit('playerHit', { targetId: id, damage: 25, attackerId: myId });
                        }
                    }
                    tryDamageBoss(state.me.x, state.me.y, 200, 25);
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 30, maxRadius: 200, life: 0.5, color: '#8b5cf6' });
                    emitAbilityEffect('shockwave', state.me.x, state.me.y);
                    showToast('Shockwave!', 'mythic'); used = true; break;
                case 'blackhole':
                    state.explosions.push({ x: state.mouse.worldX, y: state.mouse.worldY, radius: 10, maxRadius: 200, life: 1.5, color: '#1e1b4b' });
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((state.mouse.worldX - p.x)**2 + (state.mouse.worldY - p.y)**2) < 200) {
                            socket.emit('playerHit', { targetId: id, damage: 30, attackerId: myId });
                        }
                    }
                    spawnParticles(state.mouse.worldX, state.mouse.worldY, 40, '#4c1d95');
                    emitAbilityEffect('blackhole', state.mouse.worldX, state.mouse.worldY);
                    tryDamageBoss(state.mouse.worldX, state.mouse.worldY, 200, 30);
                    showToast('Blackhole!', 'mythic'); used = true; break;
                case 'nuke':
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2) < 400) {
                            socket.emit('playerHit', { targetId: id, damage: 70, attackerId: myId });
                        }
                    }
                    tryDamageBoss(state.me.x, state.me.y, 400, 70);
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 400, life: 1, color: '#dc2626' });
                    for (let i = 0; i < 60; i++) spawnParticles(state.me.x, state.me.y, 1, ['#dc2626', '#f59e0b', '#fbbf24'][Math.floor(Math.random() * 3)]);
                    emitAbilityEffect('nuke', state.me.x, state.me.y);
                    showToast('NUKE!', 'mythic'); used = true; break;
                case 'emp':
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 30, maxRadius: 250, life: 0.8, color: '#6366f1' });
                    spawnParticles(state.me.x, state.me.y, 30, '#6366f1');
                    emitAbilityEffect('emp', state.me.x, state.me.y);
                    tryDamageBoss(state.me.x, state.me.y, 250, 20);
                    showToast('EMP!', 'mythic'); used = true; break;
                case 'swap':
                    let nearest = null, nearestDist = 500;
                    for (let id in state.players) {
                        const p = state.players[id];
                        const d = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (d < nearestDist) { nearestDist = d; nearest = { id, ...p }; }
                    }
                    if (nearest) {
                        const myOldX = state.me.x;
                        const myOldY = state.me.y;
                        spawnParticles(state.me.x, state.me.y, 20, '#ec4899');
                        emitAbilityEffect('swap', state.me.x, state.me.y);
                        // Move me to target's position
                        state.me.x = nearest.x; state.me.y = nearest.y;
                        // Tell server to force-move the target to my old position
                        socket.emit('swapPositions', { targetId: nearest.id, myOldX, myOldY });
                        // Visually update target on our end immediately
                        if (state.players[nearest.id]) {
                            state.players[nearest.id].x = myOldX;
                            state.players[nearest.id].y = myOldY;
                            state.players[nearest.id].targetX = myOldX;
                            state.players[nearest.id].targetY = myOldY;
                        }
                        spawnParticles(state.me.x, state.me.y, 20, '#ec4899');
                        spawnParticles(myOldX, myOldY, 20, '#ec4899');
                        emitAbilityEffect('swap', state.me.x, state.me.y);
                        showToast('Swapped!', 'mythic'); used = true;
                    } else { showToast('No enemy nearby!', 'warning'); }
                    break;
                // NEW REGULAR POWERS - ACTUALLY UNIQUE
                case 'timebomb':
                    const bombX = state.mouse.worldX;
                    const bombY = state.mouse.worldY;
                    // Add to timebombs list - renders as small pulsing indicator on ALL screens
                    const bombId = 'bomb_' + Date.now();
                    state.timebombs.push({ id: bombId, x: bombX, y: bombY, timer: 2.0 });
                    spawnParticles(bombX, bombY, 20, '#ff6b00');
                    // Broadcast the bomb placement + scheduled explosion so all clients see it
                    socket.emit('abilityUsed', { type: 'timebomb', x: bombX, y: bombY, id: myId, bombId });
                    setTimeout(() => {
                        state.explosions.push({ x: bombX, y: bombY, radius: 30, maxRadius: 250, life: 0.8, color: '#ff6b00' });
                        for (let id in state.players) {
                            const p = state.players[id];
                            if (Math.sqrt((bombX - p.x)**2 + (bombY - p.y)**2) < 250) {
                                socket.emit('playerHit', { targetId: id, damage: 50, attackerId: myId });
                            }
                        }
                        tryDamageBoss(bombX, bombY, 250, 50);
                        for (let i = 0; i < 40; i++) spawnParticles(bombX, bombY, 1, '#ff6b00');
                        socket.emit('abilityUsed', { type: 'timebombexplode', x: bombX, y: bombY, id: myId, bombId });
                        // Remove from local timebombs
                        const bi = state.timebombs.findIndex(b => b.id === bombId);
                        if (bi !== -1) state.timebombs.splice(bi, 1);
                    }, 2000);
                    showToast('Bomb planted! 2 seconds...', 'mythic'); used = true; break;
                case 'orbitallaser':
                    const targetX = state.mouse.worldX;
                    const targetY = state.mouse.worldY;
                    // Laser warning - emit for all
                    socket.emit('abilityUsed', { type: 'orbitallaser', x: targetX, y: targetY, id: myId });
                    for (let i = 0; i < 30; i++) {
                        spawnParticles(targetX + (Math.random()-0.5)*100, -50, 1, '#00f5ff');
                    }
                    setTimeout(() => {
                        // Giant laser from sky
                        for (let i = 0; i < 100; i++) {
                            const laserY = i * 50;
                            spawnParticles(targetX, laserY, 2, '#00f5ff');
                        }
                        state.explosions.push({ x: targetX, y: targetY, radius: 40, maxRadius: 200, life: 1, color: '#00f5ff' });
                        socket.emit('abilityUsed', { type: 'orbitallaserfire', x: targetX, y: targetY, id: myId });
                        for (let id in state.players) {
                            const p = state.players[id];
                            if (Math.sqrt((targetX - p.x)**2 + (targetY - p.y)**2) < 200) {
                                socket.emit('playerHit', { targetId: id, damage: 70, attackerId: myId });
                            }
                        }
                        tryDamageBoss(targetX, targetY, 200, 70);
                    }, 1500);
                    showToast('Orbital strike incoming!', 'mythic'); used = true; break;
                case 'shadowclone':
                    const shadowX = state.me.x - Math.cos(state.me.angle) * 100;
                    const shadowY = state.me.y - Math.sin(state.me.angle) * 100;
                    spawnParticles(shadowX, shadowY, 30, '#1a1a2e');
                    socket.emit('abilityUsed', { type: 'shadowclone', x: shadowX, y: shadowY, id: myId });
                    setTimeout(() => {
                        state.explosions.push({ x: shadowX, y: shadowY, radius: 30, maxRadius: 180, life: 0.6, color: '#1a1a2e' });
                        socket.emit('abilityUsed', { type: 'shadowcloneexplode', x: shadowX, y: shadowY, id: myId });
                        for (let id in state.players) {
                            const p = state.players[id];
                            if (Math.sqrt((shadowX - p.x)**2 + (shadowY - p.y)**2) < 180) {
                                socket.emit('playerHit', { targetId: id, damage: 45, attackerId: myId });
                            }
                        }
                        tryDamageBoss(shadowX, shadowY, 180, 45);
                    }, 1000);
                    showToast('Shadow decoy!', 'mythic'); used = true; break;
                case 'frostnova':
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (dist < 300) {
                            socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                        }
                    }
                    tryDamageBoss(state.me.x, state.me.y, 300, 35);
                    for (let i = 0; i < 50; i++) {
                        const angle = (i / 50) * Math.PI * 2;
                        const dist = 50 + Math.random() * 250;
                        spawnParticles(state.me.x + Math.cos(angle)*dist, state.me.y + Math.sin(angle)*dist, 3, '#a5f3fc');
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 40, maxRadius: 300, life: 1, color: '#a5f3fc' });
                    socket.emit('abilityUsed', { type: 'frostnova', x: state.me.x, y: state.me.y, id: myId });
                    showToast('Frost Nova!', 'mythic'); used = true; break;
                case 'soulrip':
                    // Tear souls of all nearby enemies to your location, damage them and heal yourself
                    const soulRadius = 380;
                    let soulsCaught = 0;
                    spawnParticles(state.me.x, state.me.y, 60, '#7c00ff');
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 20, maxRadius: soulRadius, life: 1.2, color: '#7c00ff' });
                    socket.emit('abilityUsed', { type: 'soulrip', x: state.me.x, y: state.me.y, id: myId });
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (dist < soulRadius) {
                            soulsCaught++;
                            // Rip them toward you visually
                            spawnParticles(p.x, p.y, 20, '#a855f7');
                            // Damage
                            socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                            // Move them toward caster on their client (use swap mechanics)
                            const pullAngle = Math.atan2(state.me.y - p.y, state.me.x - p.x);
                            const pullX = p.x + Math.cos(pullAngle) * Math.min(dist * 0.7, 250);
                            const pullY = p.y + Math.sin(pullAngle) * Math.min(dist * 0.7, 250);
                            socket.emit('swapPositions', { targetId: id, myOldX: pullX, myOldY: pullY });
                            if (state.players[id]) {
                                state.players[id].targetX = pullX;
                                state.players[id].targetY = pullY;
                            }
                        }
                    }
                    // Heal self based on souls caught
                    if (soulsCaught > 0) {
                        const healAmount = soulsCaught * 8;
                        state.me.hp = Math.min(100, state.me.hp + healAmount);
                        spawnDamageNumber(state.me.x, state.me.y, healAmount, 'heal');
                    }
                    tryDamageBoss(state.me.x, state.me.y, soulRadius, 35);
                    showToast(`üíÄ SOUL RIP! (${soulsCaught} souls torn)`, 'mythic'); used = true; break;
                // NEW FUNCTIONAL POWERS
                case 'gravitypull':
                    // Pull all nearby players and powerups toward you
                    const pullRadius = 400;
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (dist < pullRadius && dist > 0) {
                            socket.emit('playerHit', { targetId: id, damage: 20, attackerId: myId });
                        }
                    }
                    // Visual effect
                    for (let i = 0; i < 40; i++) {
                        const angle = (i / 40) * Math.PI * 2;
                        const dist = pullRadius;
                        spawnParticles(
                            state.me.x + Math.cos(angle) * dist, 
                            state.me.y + Math.sin(angle) * dist, 
                            2, '#7c3aed'
                        );
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: pullRadius, life: 1, color: '#7c3aed' });
                    socket.emit('abilityUsed', { type: 'gravitypull', x: state.me.x, y: state.me.y, id: myId });
                    tryDamageBoss(state.me.x, state.me.y, pullRadius, 20);
                    showToast('üåÄ Gravity Pull!', 'mythic'); used = true; break;
                case 'mirror':
                    // Reflect projectiles back at attackers
                    state.mirrorActive = true;
                    state.omegaTimer = 8; // 8 seconds of reflection
                    for (let i = 0; i < 20; i++) {
                        const angle = (i / 20) * Math.PI * 2;
                        spawnParticles(
                            state.me.x + Math.cos(angle) * 50, 
                            state.me.y + Math.sin(angle) * 50, 
                            2, '#c0c0c0'
                        );
                    }
                    socket.emit('abilityUsed', { type: 'mirror', x: state.me.x, y: state.me.y, id: myId });
                    updateScreenEffects();
                    showToast('üõ°Ô∏è Mirror Shield Active!', 'mythic'); used = true; break;
                case 'chaos':
                    // Random teleport and damage in area
                    const chaosX = state.mouse.worldX;
                    const chaosY = state.mouse.worldY;
                    // Teleport self randomly
                    state.me.x = 100 + Math.random() * (CONFIG.map.width - 200);
                    state.me.y = 100 + Math.random() * (CONFIG.map.height - 200);
                    spawnParticles(chaosX, chaosY, 50, '#ec4899');
                    spawnParticles(state.me.x, state.me.y, 50, '#ec4899');
                    socket.emit('abilityUsed', { type: 'chaos', x: chaosX, y: chaosY, id: myId });
                    // Damage in area at click location
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((chaosX - p.x)**2 + (chaosY - p.y)**2);
                        if (dist < 250) {
                            socket.emit('playerHit', { targetId: id, damage: 45, attackerId: myId });
                        }
                    }
                    state.explosions.push({ x: chaosX, y: chaosY, radius: 30, maxRadius: 250, life: 1, color: '#ec4899' });
                    tryDamageBoss(chaosX, chaosY, 250, 45);
                    showToast('üí´ CHAOS ORB!', 'mythic'); used = true; break;
                case 'lightning':
                    // Strike lightning at mouse position - doesn't damage self
                    const ltx = state.mouse.worldX, lty = state.mouse.worldY;
                    const ltPts = Array.from({length:3}, () => ({ x: ltx + (Math.random()-0.5)*80, y: lty + (Math.random()-0.5)*80 }));
                    socket.emit('abilityUsed', { type: 'lightning', x: ltx, y: lty, id: myId, pts: ltPts });
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const boltX = ltPts[i].x, boltY = ltPts[i].y;
                            state.explosions.push({ x: boltX, y: boltY, radius: 5, maxRadius: 80, life: 0.5, color: '#facc15' });
                            spawnParticles(boltX, boltY, 20, '#facc15');
                            for (let id in state.players) {
                                const p = state.players[id];
                                if (Math.sqrt((boltX-p.x)**2+(boltY-p.y)**2) < 90) {
                                    socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                                    spawnParticles(p.x, p.y, 15, '#facc15');
                                }
                            }
                            tryDamageBoss(boltX, boltY, 90, 35);
                        }, i * 120);
                    }
                    showToast('‚ö° LIGHTNING STRIKE!', 'mythic'); used = true; break;
                case 'baby':
                    // Spawn a baby mini-player
                    if (state.baby) { showToast('Baby already active!', 'mythic'); return; }
                    state.baby = {
                        x: state.me.x + 60, y: state.me.y + 60,
                        hp: 50, angle: 0, shootCooldown: 0,
                        targetX: state.mouse.worldX, targetY: state.mouse.worldY
                    };
                    document.getElementById('baby-controls').classList.add('visible');
                    spawnParticles(state.baby.x, state.baby.y, 30, '#ff69b4');
                    socket.emit('abilityUsed', { type: 'babyspawn', x: state.baby.x, y: state.baby.y, id: myId });
                    showToast('üçº Baby spawned! Drag your mouse to guide it.', 'mythic');
                    used = true; break;
                case 'soulsteal':
                    // Drain HP from all nearby players and gain it back
                    let stolen = 0;
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 30, maxRadius: 350, life: 1.2, color: '#8800ff' });
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (dist < 350) {
                            const drain = 40;
                            socket.emit('playerHit', { targetId: id, damage: drain, attackerId: myId });
                            spawnParticles(p.x, p.y, 15, '#8800ff');
                            stolen += drain;
                        }
                    }
                    state.me.hp = Math.min(100, state.me.hp + stolen);
                    spawnParticles(state.me.x, state.me.y, 40, '#8800ff');
                    emitAbilityEffect('soulrip', state.me.x, state.me.y);
                    if (stolen > 0) spawnDamageNumber(state.me.x, state.me.y, stolen, 'heal');
                    tryDamageBoss(state.me.x, state.me.y, 350, 60);
                    showToast('üîÆ SOUL STEAL! Life drained!', 'mythic'); used = true; break;
                case 'phoenix':
                    showToast('üî• Phoenix: You will auto-revive on death!', 'mythic'); return;
                // ADMIN POWERS - ACTUALLY DEVASTATING
                case 'apocalypse':
                    // Screen-wide devastation - pre-generate positions for sync
                    const apocPts = Array.from({length:30}, () => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height }));
                    socket.emit('abilityUsed', { type: 'apocalypse', x: state.me.x, y: state.me.y, id: myId, pts: apocPts });
                    for (let i = 0; i < 30; i++) {
                        const rx = apocPts[i].x, ry = apocPts[i].y;
                        setTimeout(() => {
                            state.explosions.push({ x: rx, y: ry, radius: 40, maxRadius: 300, life: 1, color: '#ff0000' });
                            for (let id in state.players) {
                                const p = state.players[id];
                                if (Math.sqrt((rx - p.x)**2 + (ry - p.y)**2) < 300) {
                                    socket.emit('playerHit', { targetId: id, damage: 40, attackerId: myId });
                                }
                            }
                        }, i * 200);
                    }
                    showToast('APOCALYPSE', 'admin'); used = true; break;
                case 'chronobreak':
                    state.timestopActive = true;
                    state.omegaTimer = 10;
                    const cbPts = Array.from({length:100}, () => ({ x: state.me.x + (Math.random()-0.5)*500, y: state.me.y + (Math.random()-0.5)*500 }));
                    cbPts.forEach(pt => spawnParticles(pt.x, pt.y, 1, '#00ffff'));
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 400, life: 2, color: '#00ffff' });
                    socket.emit('abilityUsed', { type: 'chronobreak', x: state.me.x, y: state.me.y, id: myId, pts: cbPts });
                    updateScreenEffects();
                    showToast('CHRONO BREAK', 'admin'); used = true; break;
                case 'voidrift':
                    // Teleport all players randomly
                    for (let id in state.players) {
                        const newX = 200 + Math.random() * (CONFIG.map.width - 400);
                        const newY = 200 + Math.random() * (CONFIG.map.height - 400);
                        spawnParticles(state.players[id].x, state.players[id].y, 30, '#9333ea');
                        socket.emit('playerHit', { targetId: id, damage: 30, attackerId: myId });
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 100, maxRadius: 800, life: 2, color: '#9333ea' });
                    socket.emit('abilityUsed', { type: 'voidrift', x: state.me.x, y: state.me.y, id: myId });
                    showToast('VOID RIFT', 'admin'); used = true; break;
                case 'armageddon':
                    // Massive meteor storm - pre-generate positions
                    const armaPts = Array.from({length:40}, (_, i) => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height, delay: i*100 }));
                    socket.emit('abilityUsed', { type: 'armageddon', x: state.me.x, y: state.me.y, id: myId, pts: armaPts });
                    for (let i = 0; i < 40; i++) {
                        setTimeout(() => {
                            state.meteors.push({ x: armaPts[i].x, y: -400, targetY: armaPts[i].y, speed: 1200 });
                        }, armaPts[i].delay);
                    }
                    showToast('ARMAGEDDON', 'admin'); used = true; break;
                case 'omegabeam':
                    // Giant laser across map
                    const beamAngle = state.me.angle;
                    socket.emit('abilityUsed', { type: 'omegabeam', x: state.me.x, y: state.me.y, angle: beamAngle, id: myId });
                    for (let i = 0; i < 100; i++) {
                        const beamDist = i * 50;
                        const beamX = state.me.x + Math.cos(beamAngle) * beamDist;
                        const beamY = state.me.y + Math.sin(beamAngle) * beamDist;
                        spawnParticles(beamX, beamY, 5, '#06b6d4');
                        for (let id in state.players) {
                            const p = state.players[id];
                            if (Math.sqrt((beamX - p.x)**2 + (beamY - p.y)**2) < 60) {
                                socket.emit('playerHit', { targetId: id, damage: 100, attackerId: myId });
                            }
                        }
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 5000, life: 1.5, color: '#06b6d4' });
                    showToast('OMEGA BEAM', 'admin'); used = true; break;
                case 'singularity':
                    // Massive black hole
                    const singX = state.mouse.worldX;
                    const singY = state.mouse.worldY;
                    state.explosions.push({ x: singX, y: singY, radius: 10, maxRadius: 600, life: 5, color: '#000000' });
                    socket.emit('abilityUsed', { type: 'singularity', x: singX, y: singY, id: myId });
                    for (let wave = 0; wave < 10; wave++) {
                        setTimeout(() => {
                            for (let id in state.players) {
                                const p = state.players[id];
                                if (Math.sqrt((singX - p.x)**2 + (singY - p.y)**2) < 600) {
                                    socket.emit('playerHit', { targetId: id, damage: 15, attackerId: myId });
                                }
                            }
                            spawnParticles(singX, singY, 30, '#000000');
                        }, wave * 500);
                    }
                    showToast('SINGULARITY', 'admin'); used = true; break;
                case 'realitybomb':
                    // Warp space
                    socket.emit('abilityUsed', { type: 'realitybomb', x: state.me.x, y: state.me.y, id: myId });
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            const bombDist = (i / 20) * 500;
                            for (let angle = 0; angle < Math.PI * 2; angle += 0.5) {
                                const bx = state.me.x + Math.cos(angle) * bombDist;
                                const by = state.me.y + Math.sin(angle) * bombDist;
                                spawnParticles(bx, by, 5, '#ec4899');
                                for (let id in state.players) {
                                    const p = state.players[id];
                                    if (Math.sqrt((bx - p.x)**2 + (by - p.y)**2) < 80) {
                                        socket.emit('playerHit', { targetId: id, damage: 20, attackerId: myId });
                                    }
                                }
                            }
                        }, i * 50);
                    }
                    showToast('REALITY BOMB', 'admin'); used = true; break;
                case 'godmode':
                    state.adminGodMode = true;
                    state.me.hp = 100;
                    socket.emit('abilityUsed', { type: 'godmode', x: state.me.x, y: state.me.y, id: myId });
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 400, life: 0.5, color: '#ffd700' });
                            for (let id in state.players) {
                                const p = state.players[id];
                                if (Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2) < 400) {
                                    socket.emit('playerHit', { targetId: id, damage: 50, attackerId: myId });
                                }
                            }
                        }, i * 300);
                    }
                    setTimeout(() => { state.adminGodMode = false; }, 5000);
                    showToast('GOD MODE', 'admin'); used = true; break;
                case 'obliterate':
                    // Instant kill everyone
                    const oblPts = Array.from({length:10}, () => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height }));
                    socket.emit('abilityUsed', { type: 'obliterate', x: state.me.x, y: state.me.y, id: myId, pts: oblPts });
                    for (let id in state.players) {
                        socket.emit('playerHit', { targetId: id, damage: 9999, attackerId: myId });
                        spawnParticles(state.players[id].x, state.players[id].y, 50, '#dc2626');
                    }
                    for (let i = 0; i < 10; i++) {
                        state.explosions.push({ x: oblPts[i].x, y: oblPts[i].y, radius: 100, maxRadius: 600, life: 1, color: '#dc2626' });
                    }
                    showToast('OBLITERATE', 'admin'); used = true; break;
                // NEW UNRELEASED ADMIN POWERS FOR DEMONSTRATION
                case 'dimensionrift':
                    // Swap positions of all players randomly
                    const positions = [];
                    for (let id in state.players) {
                        positions.push({ x: state.players[id].x, y: state.players[id].y });
                    }
                    // Shuffle positions
                    positions.sort(() => Math.random() - 0.5);
                    let posIdx = 0;
                    for (let id in state.players) {
                        const newPos = positions[posIdx++];
                        spawnParticles(state.players[id].x, state.players[id].y, 40, '#8b00ff');
                        spawnParticles(newPos.x, newPos.y, 40, '#8b00ff');
                        socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 100, maxRadius: 1000, life: 2, color: '#8b00ff' });
                    socket.emit('abilityUsed', { type: 'dimensionrift', x: state.me.x, y: state.me.y, id: myId });
                    showToast('DIMENSION RIFT', 'admin'); used = true; break;
                case 'cosmicstorm':
                    // Massive area denial with rotating lasers
                    socket.emit('abilityUsed', { type: 'cosmicstorm', x: state.me.x, y: state.me.y, id: myId });
                    for (let wave = 0; wave < 8; wave++) {
                        setTimeout(() => {
                            const angle = (wave / 8) * Math.PI * 2;
                            for (let dist = 0; dist < 1000; dist += 50) {
                                const beamX = state.me.x + Math.cos(angle) * dist;
                                const beamY = state.me.y + Math.sin(angle) * dist;
                                spawnParticles(beamX, beamY, 5, '#ff1493');
                                for (let id in state.players) {
                                    const p = state.players[id];
                                    if (Math.sqrt((beamX - p.x)**2 + (beamY - p.y)**2) < 80) {
                                        socket.emit('playerHit', { targetId: id, damage: 30, attackerId: myId });
                                    }
                                }
                            }
                        }, wave * 300);
                    }
                    showToast('COSMIC STORM', 'admin'); used = true; break;
                case 'infinityvoid':
                    // Create expanding void that pulls and damages
                    const voidX = state.mouse.worldX;
                    const voidY = state.mouse.worldY;
                    socket.emit('abilityUsed', { type: 'infinityvoid', x: voidX, y: voidY, id: myId });
                    for (let wave = 0; wave < 15; wave++) {
                        setTimeout(() => {
                            const radius = wave * 40;
                            state.explosions.push({ x: voidX, y: voidY, radius: radius, maxRadius: radius + 100, life: 0.5, color: '#000033' });
                            for (let id in state.players) {
                                const p = state.players[id];
                                const dist = Math.sqrt((voidX - p.x)**2 + (voidY - p.y)**2);
                                if (dist < radius + 100) {
                                    socket.emit('playerHit', { targetId: id, damage: 20, attackerId: myId });
                                }
                            }
                            spawnParticles(voidX, voidY, 30, '#000033');
                        }, wave * 200);
                    }
                    showToast('INFINITY VOID', 'admin'); used = true; break;
                case 'starforge':
                    // Create multiple suns that damage over time
                    socket.emit('abilityUsed', { type: 'starforge', x: state.me.x, y: state.me.y, id: myId });
                    for (let i = 0; i < 5; i++) {
                        const sunX = state.me.x + Math.cos(i * Math.PI * 0.4) * 300;
                        const sunY = state.me.y + Math.sin(i * Math.PI * 0.4) * 300;
                        for (let tick = 0; tick < 20; tick++) {
                            setTimeout(() => {
                                state.explosions.push({ x: sunX, y: sunY, radius: 50, maxRadius: 150, life: 0.5, color: '#ffdf00' });
                                for (let id in state.players) {
                                    const p = state.players[id];
                                    if (Math.sqrt((sunX - p.x)**2 + (sunY - p.y)**2) < 150) {
                                        socket.emit('playerHit', { targetId: id, damage: 15, attackerId: myId });
                                    }
                                }
                                spawnParticles(sunX, sunY, 10, '#ffdf00');
                            }, (i * 500) + (tick * 200));
                        }
                    }
                    showToast('STAR FORGE', 'admin'); used = true; break;
                case 'quantumcollapse':
                    // Collapse reality - multiple effects at once - pre-generate random positions
                    const qcPts = Array.from({length:30}, () => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height }));
                    socket.emit('abilityUsed', { type: 'quantumcollapse', x: state.me.x, y: state.me.y, id: myId, pts: qcPts });
                    for (let i = 0; i < 100; i++) {
                        spawnParticles(qcPts[i % 30].x, qcPts[i % 30].y, 1, '#00fff7');
                    }
                    // Effect 2: Massive damage waves
                    for (let wave = 0; wave < 6; wave++) {
                        setTimeout(() => {
                            for (let id in state.players) {
                                socket.emit('playerHit', { targetId: id, damage: 40, attackerId: myId });
                                spawnParticles(state.players[id].x, state.players[id].y, 30, '#00fff7');
                            }
                            // Use pre-generated explosion positions
                            for (let j = 0; j < 5; j++) {
                                const pt = qcPts[(wave*5+j) % 30];
                                state.explosions.push({ x: pt.x, y: pt.y, radius: 50, maxRadius: 400, life: 1, color: '#00fff7' });
                            }
                        }, wave * 400);
                    }
                    showToast('QUANTUM COLLAPSE', 'admin'); used = true; break;
                case 'worldender':
                    // Massive ring of explosions across entire map
                    socket.emit('abilityUsed', { type: 'worldender', x: state.me.x, y: state.me.y, id: myId });
                    for (let ring = 0; ring < 5; ring++) {
                        setTimeout(() => {
                            for (let i = 0; i < 12; i++) {
                                const angle = (i / 12) * Math.PI * 2;
                                const r = (ring + 1) * 400;
                                const wx = state.me.x + Math.cos(angle) * r;
                                const wy = state.me.y + Math.sin(angle) * r;
                                state.explosions.push({ x: wx, y: wy, radius: 50, maxRadius: 300, life: 1, color: '#b91c1c' });
                                for (let id in state.players) {
                                    if (Math.sqrt((wx-state.players[id].x)**2+(wy-state.players[id].y)**2) < 300)
                                        socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                                }
                            }
                        }, ring * 250);
                    }
                    showToast('WORLD ENDER', 'admin'); used = true; break;
                case 'divinebeam':
                    // Beam from above targeting all enemies
                    socket.emit('abilityUsed', { type: 'divinebeam', x: state.me.x, y: state.me.y, id: myId });
                    for (let id in state.players) {
                        const p = state.players[id];
                        const pxSnap = p.x, pySnap = p.y;
                        socket.emit('abilityUsed', { type: 'divinebeamtarget', x: pxSnap, y: pySnap, id: myId });
                        for (let tick = 0; tick < 10; tick++) {
                            setTimeout(() => {
                                spawnParticles(pxSnap, pySnap - tick*30, 5, '#f0abfc');
                                state.explosions.push({ x: pxSnap, y: pySnap, radius: 10, maxRadius: 60, life: 0.4, color: '#f0abfc' });
                                socket.emit('playerHit', { targetId: id, damage: 10, attackerId: myId });
                            }, tick * 100);
                        }
                    }
                    showToast('DIVINE BEAM', 'admin'); used = true; break;
                case 'blacksun':
                    // Create a massive darkness that damages all
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 2000, life: 3, color: '#1c1c1c' });
                    socket.emit('abilityUsed', { type: 'blacksun', x: state.me.x, y: state.me.y, id: myId });
                    for (let wave = 0; wave < 10; wave++) {
                        setTimeout(() => {
                            for (let id in state.players) {
                                socket.emit('playerHit', { targetId: id, damage: 25, attackerId: myId });
                            }
                            spawnParticles(state.me.x, state.me.y, 20, '#1c1c1c');
                        }, wave * 200);
                    }
                    showToast('BLACK SUN', 'admin'); used = true; break;
                case 'stormcall':
                    // Lightning strikes randomly across map - pre-generate positions
                    const scPts = Array.from({length:20}, () => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height }));
                    socket.emit('abilityUsed', { type: 'stormcall', x: state.me.x, y: state.me.y, id: myId, pts: scPts });
                    for (let bolt = 0; bolt < 20; bolt++) {
                        setTimeout(() => {
                            const bx = scPts[bolt].x, by = scPts[bolt].y;
                            state.explosions.push({ x: bx, y: by, radius: 5, maxRadius: 120, life: 0.4, color: '#60a5fa' });
                            spawnParticles(bx, by, 10, '#60a5fa');
                            for (let id in state.players) {
                                if (Math.sqrt((bx-state.players[id].x)**2+(by-state.players[id].y)**2) < 120)
                                    socket.emit('playerHit', { targetId: id, damage: 30, attackerId: myId });
                            }
                        }, bolt * 150);
                    }
                    showToast('STORM CALL', 'admin'); used = true; break;
            }
            if (used && !state.adminInfinite) {
                state.me.currentPower = null; state.me.isOmegaPower = false; state.me.isAdminPower = false;
                state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
                updatePowerUI(null); broadcastState();
            }
            // All used powers damage the boss ‚Äî admin powers hit much harder
            if (used) {
                const isAdmin = ADMIN_POWERS[powerType];
                tryDamageBoss(state.me.x, state.me.y, isAdmin ? 2000 : 300, isAdmin ? 150 : 25);
            }
        }

        function tryDrop() {
            if (!state.me || !state.me.currentPower) {
                showToast('Nothing to drop!', 'warning'); return;
            }
            const droppedPower = state.me.currentPower;
            const powerInfo = ALL_POWERS[droppedPower];
            // Only Omega powers can't be dropped - they vanish
            if (state.me.isOmegaPower && OMEGA_POWER[droppedPower]) {
                spawnParticles(state.me.x, state.me.y, 20, powerInfo.color);
                showToast(`${powerInfo.name} destroyed!`, 'mythic');
                state.me.currentPower = null; state.me.isOmegaPower = false;
                updatePowerUI(null); broadcastState(); return;
            }
            const dropId = 'drop_' + (powerupIdCounter++);
            const dropX = state.me.x + Math.cos(state.me.angle + Math.PI) * 50;
            const dropY = state.me.y + Math.sin(state.me.angle + Math.PI) * 50;
            state.powerups[dropId] = {
                id: dropId, type: droppedPower,
                x: Math.max(50, Math.min(CONFIG.map.width - 50, dropX)),
                y: Math.max(50, Math.min(CONFIG.map.height - 50, dropY))
            };
            socket.emit('dropPower', { type: droppedPower, x: state.powerups[dropId].x, y: state.powerups[dropId].y });
            spawnParticles(state.me.x, state.me.y, 10, powerInfo.color);
            state.me.currentPower = null; state.speedActive = false;
            state.phaseActive = false; state.berserkerActive = false;
            updatePowerUI(null); broadcastState();
            showToast(`Dropped ${powerInfo.name}!`, 'mythic');
        }

        function recallBaby() {
            if (!state.baby) return;
            spawnParticles(state.baby.x, state.baby.y, 20, '#ff69b4');
            socket.emit('abilityUsed', { type: 'babyrecall', x: state.baby.x, y: state.baby.y, id: myId });
            state.baby = null;
            document.getElementById('baby-controls').classList.remove('visible');
            showToast('Baby recalled!', 'mythic');
        }

        function destructBaby() {
            if (!state.baby) return;
            state.explosions.push({ x: state.baby.x, y: state.baby.y, radius: 20, maxRadius: 200, life: 0.8, color: '#ff69b4' });
            for (let i = 0; i < 40; i++) spawnParticles(state.baby.x, state.baby.y, 1, '#ff69b4');
            for (let id in state.players) {
                const p = state.players[id];
                if (Math.sqrt((state.baby.x-p.x)**2+(state.baby.y-p.y)**2) < 200) {
                    socket.emit('playerHit', { targetId: id, damage: 40, attackerId: myId });
                }
            }
            socket.emit('abilityUsed', { type: 'babydestruct', x: state.baby.x, y: state.baby.y, id: myId });
            emitAbilityEffect('shockwave', state.baby.x, state.baby.y);
            state.baby = null;
            document.getElementById('baby-controls').classList.remove('visible');
            showToast('üí• Baby self-destructed!', 'mythic');
        }

        function sendChat() {
            const input = document.getElementById('chat-input');
            const txt = input.value.trim();
            if (txt && state.me && socket) {
                socket.emit('chatMessage', { text: txt, playerName: state.me.name });
                input.value = ''; input.blur();
            }
        }

        window.onload = initSupabase;
    </script>
</body>
</html>
