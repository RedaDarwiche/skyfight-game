<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SkyFight.io - Updated</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <style>
        :root {
            --sky-dark: #4facfe;
            --sky-light: #00f2fe;
            --white-glass: rgba(255, 255, 255, 0.3);
            --glass-border: rgba(255, 255, 255, 0.6);
            --text-color: #2c3e50;
            --boost-green: #2ecc71;
            --boost-red: #e74c3c;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #4facfe, #00f2fe);
            height: 100vh;
            width: 100vw;
        }

        #gameCanvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 0;
            display: block;
        }

        #top-left-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
            transition: opacity 0.3s;
        }

        #nav-login-btn {
            background: linear-gradient(45deg, var(--sky-dark), var(--sky-light));
            color: white;
            border: 2px solid white;
            padding: 16px 32px;
            border-radius: 50px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.3rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        #nav-login-btn:hover { transform: scale(1.05); }
        #top-right-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
        }

        #forum-nav-btn {
            background: linear-gradient(45deg, var(--sky-dark), var(--sky-light));
            color: white;
            border: 2px solid white;
            padding: 16px 32px;
            border-radius: 50px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.3rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        #forum-nav-btn:hover { transform: scale(1.05); }

        #profile-card {
            background: var(--white-glass);
            backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
            padding: 15px 20px;
            border-radius: 20px;
            display: none;
            min-width: 200px;
        }

        .profile-avatar {
            width: 40px; height: 40px;
            background: linear-gradient(45deg, var(--sky-dark), var(--sky-light));
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            margin-right: 10px;
        }

        #display-username {
            font-family: 'Fredoka One';
            color: var(--text-color);
            font-size: 1.2rem;
        }

        .logout-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 10px;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
            margin-top: 10px;
        }

        #main-menu {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            width: 100%;
            max-width: 400px;
            z-index: 15;
        }

        h1.logo {
            font-family: 'Fredoka One', cursive;
            font-size: 5.5rem;
            background: -webkit-linear-gradient(#fff, #c3f0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0px 4px 0px rgba(0,0,0,0.1));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        .menu-input-container {
            width: 100%;
            background: var(--white-glass);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid var(--glass-border);
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .glass-input {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255,255,255,0.6);
            border-radius: 12px;
            font-family: 'Nunito', sans-serif;
            font-size: 1.1rem;
            background: rgba(255,255,255,0.8);
            text-align: center;
            transition: all 0.2s;
            outline: none;
            color: var(--text-color);
        }
        .glass-input:focus {
            border-color: var(--sky-dark);
            background: white;
            transform: scale(1.02);
        }

        .btn-main {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            cursor: pointer;
            color: white;
            background: linear-gradient(to bottom, var(--sky-dark), var(--sky-light));
            box-shadow: 0 5px 0 #2a8bc4;
            transition: all 0.1s;
        }
        .btn-main:active { transform: translateY(5px); box-shadow: 0 0 0 #2a8bc4; }

        #auth-modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 40px 30px 30px 30px;
            border-radius: 25px;
            width: 420px;
            max-width: 90%;
            text-align: center;
            position: relative;
            animation: popIn 0.3s;
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .modal-tab {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            background: #f5f5f5;
            border-radius: 12px;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            font-size: 1.1rem;
            transition: all 0.2s;
            color: #888;
        }

        .modal-tab.active {
            background: linear-gradient(45deg, var(--sky-dark), var(--sky-light));
            color: white;
            border-color: var(--sky-dark);
        }

        .input-group {
            margin-bottom: 15px;
            text-align: left;
        }

        .input-group label {
            display: block;
            font-size: 0.9rem;
            margin-bottom: 5px;
            color: #666;
            font-weight: bold;
        }

        .modal-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #eee;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            background: #f9f9f9;
        }
        .modal-input:focus {
            border-color: var(--sky-dark);
            outline: none;
            background: white;
        }

        .close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            font-size: 1.5rem;
            cursor: pointer;
            color: #999;
            line-height: 1;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
            background: #f0f0f0;
            font-weight: bold;
        }
        .close-btn:hover { color: #666; background: #e0e0e0; }

        .modal-btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.3rem;
            cursor: pointer;
            color: white;
            background: linear-gradient(to bottom, var(--sky-dark), var(--sky-light));
            box-shadow: 0 4px 0 #2a8bc4;
            margin-top: 10px;
        }
        .modal-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #2a8bc4; }

        #confirm-msg {
            display: none;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 12px;
            color: #2e7d32;
            font-weight: bold;
        }

        #animal-selection {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 150;
            justify-content: center;
            align-items: center;
        }

        .selection-container {
            background: white;
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            animation: popIn 0.4s;
        }

        .selection-container h2 {
            font-family: 'Fredoka One', cursive;
            font-size: 2.5rem;
            margin-bottom: 30px;
            background: -webkit-linear-gradient(var(--sky-dark), var(--sky-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .animal-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .animal-card {
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0);
            padding: 25px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .animal-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
            border-color: var(--sky-dark);
        }

        .animal-card h3 {
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        #leaderboard {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--white-glass);
            backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
            padding: 15px;
            border-radius: 15px;
            min-width: 220px;
            z-index: 10;
        }

        #leaderboard h3 {
            font-family: 'Fredoka One', cursive;
            color: white;
            margin-bottom: 10px;
            text-align: center;
            font-size: 1.3rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .leaderboard-entry {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            color: var(--text-color);
            font-size: 0.9rem;
        }

        .leaderboard-entry.self {
            background: linear-gradient(45deg, var(--boost-green), #27ae60);
            color: white;
        }

        #boost-container {
            display: none;
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            gap: 10px;
            z-index: 10;
            flex-direction: column;
            align-items: center;
        }

        .boost-bars {
            display: flex;
            gap: 10px;
        }

        .boost-bar {
            width: 80px;
            height: 30px;
            background: rgba(0,0,0,0.4);
            border: 3px solid white;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .boost-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.2s;
        }

        .boost-bar.full .boost-bar-fill {
            width: 100%;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #ability-display {
            display: none;
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Fredoka One';
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 8px 20px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.5);
            font-size: 1rem;
            z-index: 10;
        }

        #evolution-bar {
            display: none;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--white-glass);
            backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
            padding: 15px 20px;
            border-radius: 20px;
            z-index: 10;
            min-width: 400px;
        }

        .evolution-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .evolution-option {
            flex: 1;
            background: linear-gradient(135deg, #fff, #f0f0f0);
            padding: 15px;
            border-radius: 12px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }

        .evolution-option:hover {
            transform: translateY(-5px);
            border-color: var(--sky-dark);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .evolution-option h4 {
            font-family: 'Fredoka One';
            font-size: 1.1rem;
            margin-bottom: 5px;
            color: var(--text-color);
        }

        .evolution-option p {
            font-size: 0.8rem;
            color: #666;
        }

        #death-screen {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 250;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #death-screen h2 {
            font-family: 'Fredoka One', cursive;
            font-size: 4rem;
            color: #e74c3c;
            margin-bottom: 20px;
            text-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }

        #death-screen p {
            font-family: 'Nunito', sans-serif;
            font-size: 1.5rem;
            color: white;
            margin-bottom: 30px;
        }

        #death-screen button {
            background: linear-gradient(45deg, var(--sky-dark), var(--sky-light));
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.3rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }

        #death-screen button:hover {
            transform: scale(1.05);
        }

        #chat-container {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 350px;
            z-index: 10;
        }

        #chat-messages {
            background: var(--white-glass);
            backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
            border-radius: 15px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .chat-message {
            background: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .chat-message .sender {
            font-weight: bold;
            color: var(--sky-dark);
        }

        #chat-input-container {
            display: none;
            background: var(--white-glass);
            backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
            border-radius: 15px;
            padding: 10px;
        }

        #chat-input {
            width: 100%;
            padding: 10px;
            border: 2px solid rgba(255,255,255,0.6);
            border-radius: 8px;
            font-family: 'Nunito', sans-serif;
            background: rgba(255,255,255,0.9);
            outline: none;
        }

        #toast {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            z-index: 500;
            transition: bottom 0.3s;
            font-weight: bold;
        }
        #toast.show { bottom: 150px; }
        #toast.success { background: var(--boost-green); }
        #toast.error { background: #ff6b6b; }
        /* FORUM STYLES */
        #forum-modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 300;
            justify-content: center;
            align-items: center;
        }

        .forum-container {
            background: white;
            width: 90%;
            max-width: 800px;
            height: 80vh;
            border-radius: 25px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: popIn 0.3s;
        }

        .forum-header {
            background: linear-gradient(135deg, var(--sky-dark), var(--sky-light));
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .forum-header h2 {
            font-family: 'Fredoka One', cursive;
            font-size: 2rem;
            margin: 0;
        }

        .forum-close-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .forum-close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .forum-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px 30px;
        }

        .forum-create-section {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.1));
            border: 2px solid rgba(79, 172, 254, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .forum-create-section h3 {
            font-family: 'Fredoka One', cursive;
            color: var(--text-color);
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .forum-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            margin-bottom: 10px;
            transition: border-color 0.2s;
        }
        .forum-input:focus {
            outline: none;
            border-color: var(--sky-dark);
        }

        .forum-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .forum-category-select {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .category-btn {
            padding: 10px 20px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-weight: bold;
            transition: all 0.2s;
        }
        .category-btn:hover {
            border-color: var(--sky-dark);
            transform: translateY(-2px);
        }
        .category-btn.selected {
            background: linear-gradient(135deg, var(--sky-dark), var(--sky-light));
            color: white;
            border-color: transparent;
        }

        .forum-create-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--sky-dark), var(--sky-light));
            color: white;
            border: none;
            border-radius: 12px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.2rem;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 0 #2a8bc4;
        }
        .forum-create-btn:hover {
            transform: translateY(-2px);
        }
        .forum-create-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #2a8bc4;
        }
        .forum-create-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .cooldown-text {
            color: #e74c3c;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
            font-family: 'Fredoka One', cursive;
        }

        .forum-posts-section h3 {
            font-family: 'Fredoka One', cursive;
            color: var(--text-color);
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .forum-post {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.2s;
        }
        .forum-post:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
            border-color: var(--sky-dark);
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .post-category {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: bold;
            font-family: 'Fredoka One', cursive;
        }
        .post-category.suggestion { 
            background: linear-gradient(135deg, #3498db, #2980b9); 
            color: white; 
        }
        .post-category.game { 
            background: linear-gradient(135deg, #2ecc71, #27ae60); 
            color: white; 
        }
        .post-category.bug { 
            background: linear-gradient(135deg, #e74c3c, #c0392b); 
            color: white; 
        }
        .post-category.humor { 
            background: linear-gradient(135deg, #f39c12, #e67e22); 
            color: white; 
        }

        .post-author {
            color: #7f8c8d;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .post-title {
            font-family: 'Fredoka One', cursive;
            font-size: 1.3rem;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .post-description {
            color: #555;
            line-height: 1.6;
        }

        .post-time {
            color: #95a5a6;
            font-size: 0.85rem;
            margin-top: 10px;
        }

        .no-posts {
            text-align: center;
            color: #95a5a6;
            padding: 40px;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="top-left-ui">
        <button id="nav-login-btn">Login</button>
        <div id="profile-card">
            <div>
               <span class="profile-avatar" id="profile-avatar">P</span>
                <span id="display-username">Player</span>
            </div>
            <button class="logout-btn" onclick="handleLogout()">Logout</button>
        </div>
    </div>
    <div id="top-right-ui">
        <button id="forum-nav-btn" onclick="openForum()">Forum</button>
    </div>

    <div id="main-menu">
        <h1 class="logo">SkyFight.io</h1>
        <div class="menu-input-container">
            <input type="text" id="guest-name" class="glass-input" placeholder="Enter Nickname" maxlength="15">
            <button class="btn-main" onclick="prepareGame()">Play</button>
        </div>
    </div>

    <div id="auth-modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeAuthModal()">X</span>
            <div class="modal-tabs">
                <div class="modal-tab active" onclick="switchAuthTab('login')">Login</div>
                <div class="modal-tab" onclick="switchAuthTab('signup')">Sign Up</div>
            </div>
            <div id="auth-form">
                <div id="login-form">
                    <div class="input-group">
                        <label>Email</label>
                        <input type="email" id="login-email" class="modal-input" placeholder="your@email.com">
                    </div>
                    <div class="input-group">
                        <label>Password</label>
                        <input type="password" id="login-password" class="modal-input" placeholder="********">
                    </div>
                    <button class="modal-btn" onclick="handleLogin()">Log In</button>
                </div>
                <div id="signup-form" style="display: none;">
                    <div class="input-group">
                        <label>Username</label>
                        <input type="text" id="signup-username" class="modal-input" placeholder="Choose a username">
                    </div>
                    <div class="input-group">
                        <label>Email</label>
                        <input type="email" id="signup-email" class="modal-input" placeholder="your@email.com">
                    </div>
                    <div class="input-group">
                        <label>Password</label>
                        <input type="password" id="signup-password" class="modal-input" placeholder="********">
                    </div>
                    <button class="modal-btn" onclick="handleSignup()">Create Account</button>
                </div>
            </div>
            <div id="confirm-msg">
                <p style="font-size: 1.1rem; margin-bottom: 10px;">Account Created!</p>
                <p>Please check your email to confirm your account.</p>
            </div>
        </div>
    </div>

    <div id="animal-selection">
        <div class="selection-container">
            <h2>Choose Your Insect</h2>
            <div class="animal-grid" id="animal-grid"></div>
        </div>
    </div>

    <div id="evolution-bar">
        <div style="text-align: center; margin-bottom: 10px;">
            <h4 style="font-family: 'Fredoka One'; color: var(--text-color); margin-bottom: 5px;">Evolution Available!</h4>
            <p style="font-size: 0.9rem; color: #666;">Choose your next form or stay as current</p>
        </div>
        <div class="evolution-options" id="evolution-options"></div>
    </div>

    <div id="leaderboard">
        <h3>Leaderboard</h3>
        <div id="leaderboard-list"></div>
    </div>

    <div id="boost-container">
        <div class="boost-bars">
            <div class="boost-bar" id="boost-bar-1"><div class="boost-bar-fill"></div></div>
            <div class="boost-bar" id="boost-bar-2"><div class="boost-bar-fill"></div></div>
            <div class="boost-bar" id="boost-bar-3"><div class="boost-bar-fill"></div></div>
        </div>
    </div>
    
    <div id="ability-display">Ability Ready [E]</div>

    <div id="chat-container">
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type message..." maxlength="100">
        </div>
    </div>

    <div id="death-screen">
        <h2>You Died!</h2>
        <p id="death-stats">You reached Tier 1 with 0 XP</p>
        <button onclick="returnToMenu()">Return to Menu</button>
    </div>

    <div id="toast"></div>
     <!-- FORUM MODAL -->
    <div id="forum-modal">
        <div class="forum-container">
            <div class="forum-header">
                <h2>Community Forum</h2>
                <button class="forum-close-btn" onclick="closeForum()">Ã—</button>
            </div>
            
            <div class="forum-content">
                <!-- Create Post Section -->
                <div class="forum-create-section">
                    <h3>Create a Post</h3>
                    
                    <div class="forum-category-select">
                        <button class="category-btn" data-category="suggestion" onclick="selectCategory('suggestion')">SUGGESTION</button>
                        <button class="category-btn" data-category="game" onclick="selectCategory('game')">GAME</button>
                        <button class="category-btn" data-category="bug" onclick="selectCategory('bug')">BUG</button>
                        <button class="category-btn" data-category="humor" onclick="selectCategory('humor')">HUMOR</button>
                    </div>
                    
                    <input type="text" id="forum-title" class="forum-input" placeholder="Post Title" maxlength="100">
                    <textarea id="forum-description" class="forum-input forum-textarea" placeholder="Describe your post..." maxlength="500"></textarea>
                    
                    <button class="forum-create-btn" onclick="createForumPost()" id="create-post-btn">Create Post</button>
                    <div class="cooldown-text" id="forum-cooldown" style="display: none;"></div>
                </div>
                
                <!-- Posts List Section -->
                <div class="forum-posts-section">
                    <h3>Recent Posts</h3>
                    <div id="forum-posts-list">
                        <div class="no-posts">No posts yet. Be the first to post!</div>
                    </div>
                </div>
            </div>
        </div>
    </div>   
    <script>
        const SUPABASE_URL = 'https://jppfsqkshcmwskcdsqis.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpwcGZzcWtzaGNtd3NrY2RzcWlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA5MjczMzgsImV4cCI6MjA4NjUwMzMzOH0.ACkiOnXuKGnzKTqi2HSLggktIzrRWOFLje-dp20dpqU';
        // Create the client instance and overwrite the global variable
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let currentUser = null;
        let socket = null;
        let isConnected = false;
        const otherPlayers = {};
        const SERVER_URL = 'https://skyfight-server.onrender.com'; // We'll replace this later
        function connectToServer() {
            if (socket && isConnected) return;
            
            socket = io(SERVER_URL);
            
            socket.on('connect', () => {
                console.log('Connected to server!');
                isConnected = true;
                showToast('Connected to multiplayer!', 'success');
                
                // If player already exists (game already started), join immediately
                if (player && gameRunning) {
                    socket.emit('playerJoin', {
    x: player.x,
    y: player.y,
    angle: player.angle,
    name: playerName,
    userId: currentUser ? currentUser.id : null, // ADD THIS LINE
                        color: player.color,
                        size: player.size,
                        tier: player.tier,
                        hp: player.hp,
                        xp: player.xp,
                        animalType: player.animalData.name
                    });
                    
                    // Re-register all local bots with server after reconnect
                    Object.values(bots).forEach(bot => {
                        if (!bot.isRemote) {
                            socket.emit('botSpawned', {
                                botId: bot.botId,
                                x: bot.x,
                                y: bot.y,
                                tier: bot.tier,
                                animalIndex: bot.animalIndex,
                                hp: bot.hp,
                                maxHp: bot.maxHp
                            });
                        }
                    });
                }
            });
            
            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                isConnected = false;
            });
            
            socket.on('currentPlayers', (players) => {
                Object.keys(players).forEach(id => {
                    if (id !== socket.id) {
                        otherPlayers[id] = createOtherPlayer(players[id]);
                    }
                });
            });
            
            socket.on('newPlayer', (playerData) => {
                otherPlayers[playerData.id] = createOtherPlayer(playerData);
            });
            
            socket.on('playerMoved', (data) => {
                if (otherPlayers[data.id]) {
                    otherPlayers[data.id].x = data.x;
                    otherPlayers[data.id].y = data.y;
                    otherPlayers[data.id].angle = data.angle;
                    otherPlayers[data.id].vx = data.vx || 0;
                    otherPlayers[data.id].vy = data.vy || 0;
                }
            });
            
            socket.on('playerUpdated', (data) => {
                if (otherPlayers[data.id]) {
                    const oldTier = otherPlayers[data.id].tier;
                    
                    // If tier changed, they evolved
                    if (data.tier && data.tier !== oldTier && data.animalIndex !== undefined) {
                        otherPlayers[data.id].evolve(data.tier, data.animalIndex);
                    }
                    
                    otherPlayers[data.id].xp = data.xp;
                }
            });
            
            socket.on('playerDisconnected', (playerId) => {
    delete otherPlayers[playerId];
});
// Handle duplicate name error
socket.on('joinError', (data) => {
    showToast(data.message, 'error');
    
    // Completely disconnect the socket
    if (socket) {
        socket.disconnect();
        socket = null;
    }
    
    isConnected = false;
    gameRunning = false;
    player = null;
    otherPlayers = {};
    
    document.getElementById('main-menu').style.display = 'flex';
    document.getElementById('leaderboard').style.display = 'none';
    document.getElementById('boost-container').style.display = 'none';
    document.getElementById('ability-display').style.display = 'none';
    document.getElementById('chat-container').style.display = 'none';
    document.getElementById('evolution-bar').style.display = 'none';
});

socket.on('gotHit', (data) => {
    // We got hit by another player!
    if (player && gameRunning && !player.isDead) {
        player.hp -= data.damage;
        player.hitFlash = 1;
        
        damageTexts.push(new DamageText(player.x, player.y - player.size - 20, data.damage, '#e74c3c'));
        for (let i = 0; i < 5; i++) {
            particles.push(new Particle(player.x, player.y, player.color, 'hit'));
        }
        
        if (player.hp <= 0) {
            player.hp = 0;
            player.isDead = true;
            playerDied();
        }
    }
});
socket.on('chatMessage', (data) => {
    // Receive chat from other players - combine name + message
    const fullMessage = data.playerName + ' ' + data.text;
    chatMessages.push({ text: fullMessage, time: Date.now() });
    if (chatMessages.length > 5) chatMessages.shift();
    updateChatDisplay();
});

// === BOT SYNCHRONIZATION SOCKET HANDLERS ===
socket.on('existingBots', (serverBots) => {
    // Receive existing bots when joining
    Object.keys(serverBots).forEach(botId => {
        const botData = serverBots[botId];
        if (!bots[botId] && !botData.isDead) {
            const bot = new Bot(botData.x, botData.y, botId);
            bot.tier = botData.tier;
            bot.animalIndex = botData.animalIndex;
            bot.hp = botData.hp;
            bot.maxHp = botData.maxHp;
            bot.isRemote = true;
            bot.animalData = TIER_ANIMALS[bot.tier][bot.animalIndex];
            bot.updateStats();
            bots[botId] = bot;
        }
    });
});

socket.on('botSpawnConfirmed', (data) => {
    // Server confirmed our bot spawn (in case server assigned a different ID)
    // Usually not needed if client sends botId, but good for validation
    console.log('Bot spawn confirmed:', data.botId);
});

socket.on('remoteBotSpawned', (botData) => {
    // Another player spawned a bot
    if (!bots[botData.id] && !botData.isDead) {
        const bot = new Bot(botData.x, botData.y, botData.id);
        bot.tier = botData.tier;
        bot.animalIndex = botData.animalIndex;
        bot.hp = botData.hp;
        bot.maxHp = botData.maxHp;
        bot.isRemote = true;
        bot.animalData = TIER_ANIMALS[bot.tier][bot.animalIndex];
        bot.updateStats();
        bots[botData.id] = bot;
    }
});

socket.on('remoteBotMoved', (data) => {
    if (bots[data.botId] && bots[data.botId].isRemote) {
        bots[data.botId].x = data.x;
        bots[data.botId].y = data.y;
        bots[data.botId].angle = data.angle;
    }
});

socket.on('remoteBotDamaged', (data) => {
    if (bots[data.botId]) {
        bots[data.botId].hp = data.hp;
        bots[data.botId].hitFlash = 1;
    }
});

socket.on('remoteBotDied', (data) => {
    if (bots[data.botId]) {
        bots[data.botId].isDead = true;
    }
});

socket.on('remoteBotRespawned', (botData) => {
    if (bots[botData.id]) {
        bots[botData.id].isDead = false;
        bots[botData.id].x = botData.x;
        bots[botData.id].y = botData.y;
        bots[botData.id].hp = botData.hp;
        bots[botData.id].tier = botData.tier;
        bots[botData.id].animalIndex = botData.animalIndex;
        bots[botData.id].animalData = TIER_ANIMALS[botData.tier][botData.animalIndex];
        bots[botData.id].updateStats();
    }
});

socket.on('remoteBotRemoved', (data) => {
    // Remove bot when owner disconnects
    if (bots[data.botId]) {
        delete bots[data.botId];
    }
});

socket.on('botDamaged', (data) => {
    // DEPRECATED - kept for backwards compatibility
    // Update bot on all clients
    if (bots[data.botId]) {
        bots[data.botId].hp = data.hp;
        bots[data.botId].isDead = data.isDead;
        bots[data.botId].hitFlash = 1;
    }
});
            
            socket.on('playerDeath', (playerId) => {
                if (otherPlayers[playerId]) {
                    for (let i = 0; i < 20; i++) {
                        particles.push(new Particle(otherPlayers[playerId].x, otherPlayers[playerId].y, otherPlayers[playerId].color, 'hit'));
                    }
                    delete otherPlayers[playerId];
                }
            });
        }
        
        function createOtherPlayer(data) {
            // Find the animal index from the name
            let animalIndex = 0;
            const tierAnimals = TIER_ANIMALS[data.tier || 1];
            if (tierAnimals) {
                for (let i = 0; i < tierAnimals.length; i++) {
                    if (tierAnimals[i].name === data.animalType) {
                        animalIndex = i;
                        break;
                    }
                }
            }
            
            // Create a real Entity
            const entity = new Entity(data.x, data.y, data.name, animalIndex, true);
            entity.id = data.id;
            entity.tier = data.tier || 1;
            entity.xp = data.xp || 0;
            entity.angle = data.angle || 0;
            entity.isOtherPlayer = true; // Mark as other player
            
            return entity;
        }
        async function initAuth() {
            const { data: { session } } = await supabase.auth.getSession();
            if (session) {
                currentUser = session.user;
                showProfile();
            }
            supabase.auth.onAuthStateChange((event, session) => {
                if (event === 'SIGNED_IN') {
                    currentUser = session.user;
                    showProfile();
                } else if (event === 'SIGNED_OUT') {
                    currentUser = null;
                    hideProfile();
                }
            });
        }

        function showProfile() {
            document.getElementById('nav-login-btn').style.display = 'none';
            document.getElementById('profile-card').style.display = 'block';
            document.getElementById('display-username').innerText = 
                currentUser.user_metadata?.username || currentUser.email.split('@')[0];
        }

        function hideProfile() {
            document.getElementById('nav-login-btn').style.display = 'block';
            document.getElementById('profile-card').style.display = 'none';
        }

        function openAuthModal() {
            document.getElementById('auth-modal').style.display = 'flex';
            switchAuthTab('login');
        }

        function closeAuthModal() {
            document.getElementById('auth-modal').style.display = 'none';
            document.getElementById('confirm-msg').style.display = 'none';
            document.getElementById('auth-form').style.display = 'block';
        }

        function switchAuthTab(tab) {
            const tabs = document.querySelectorAll('.modal-tab');
            tabs.forEach(t => t.classList.remove('active'));
            if (tab === 'login') {
                tabs[0].classList.add('active');
                document.getElementById('login-form').style.display = 'block';
                document.getElementById('signup-form').style.display = 'none';
            } else {
                tabs[1].classList.add('active');
                document.getElementById('login-form').style.display = 'none';
                document.getElementById('signup-form').style.display = 'block';
            }
        }

        async function handleLogin() {
            const email = document.getElementById('login-email').value.trim();
            const password = document.getElementById('login-password').value;
            if (!email || !password) { showToast("Fill all fields", "error"); return; }
            try {
                const { error } = await supabase.auth.signInWithPassword({ email, password });
                if (error) throw error;
                showToast("Login Successful!", "success");
                closeAuthModal();
            } catch (err) { showToast(err.message, "error"); }
        }

        async function handleSignup() {
            const username = document.getElementById('signup-username').value.trim();
            const email = document.getElementById('signup-email').value.trim();
            const password = document.getElementById('signup-password').value;
            if (!username || !email || !password) { showToast("Fill all fields", "error"); return; }
            try {
                const { data, error } = await supabase.auth.signUp({
                    email,
                    password,
                    options: { data: { username: username } }
                });
                if (error) throw error;

                // Check if we are logged in immediately (Auto-confirm enabled)
                if (data.session) {
                    showToast("Account Created & Logged In!", "success");
                    closeAuthModal();
                } else {
                    // Verification required
                    document.getElementById('auth-form').style.display = 'none';
                    document.getElementById('confirm-msg').style.display = 'block';
                    document.getElementById('confirm-msg').innerHTML = 
                        '<p style="font-size: 1.1rem; margin-bottom: 10px;">Account Created!</p>' +
                        '<p>If you do not see an email, check your Spam folder.</p>';
                }
            } catch (err) { showToast(err.message, "error"); }
        }

        async function handleLogout() {
            await supabase.auth.signOut();
            showToast("Logged Out", "success");
            location.reload();
        }

        document.getElementById('nav-login-btn').addEventListener('click', openAuthModal);
        initAuth();

        const CANVAS_WIDTH = 8000;
        const CANVAS_HEIGHT = 8000;
        const FOOD_PER_BOOST = 5;
        
        const ABILITIES = {
            'stun': { name: 'Lava Stun', desc: 'Stun nearby enemies for 3s', cooldown: 10, color: '#e74c3c' },
            'poison': { name: 'Poison Sting', desc: 'Poison enemies over time', cooldown: 8, color: '#9b59b6' },
            'speed': { name: 'Swift Flight', desc: 'Boost speed for 4s', cooldown: 12, color: '#3498db' },
            'rage': { name: 'Fury', desc: 'Double damage for 5s', cooldown: 15, color: '#e74c3c' },
            'strike': { name: 'Ambush Strike', desc: 'Dash and deal heavy damage', cooldown: 10, color: '#27ae60' },
            'invisible': { name: 'Camouflage', desc: 'Become invisible for 4s', cooldown: 20, color: '#95a5a6' },
            'fear': { name: 'Intimidate', desc: 'Scare enemies away for 3s', cooldown: 12, color: '#8e44ad' },
            'shield': { name: 'Iron Shell', desc: 'Become invincible for 3s', cooldown: 25, color: '#f39c12' },
            'venom': { name: 'Venom Blast', desc: 'Poison cloud damages all nearby', cooldown: 14, color: '#16a085' },
            'regenerate': { name: 'Regeneration', desc: 'Heal over time for 6s', cooldown: 18, color: '#27ae60' }
        };
        
        const TIER_ANIMALS = {
            1: [
                { name: 'Fruit Fly', hp: 60, speed: 3.5, damage: 8, size: 20, color: '#ff9ff3', type: 'fly' },
                { name: 'House Fly', hp: 70, speed: 3.2, damage: 10, size: 22, color: '#576574', type: 'fly' },
                { name: 'Mosquito', hp: 65, speed: 3.3, damage: 9, size: 21, color: '#ff6b6b', type: 'mosquito' }
            ],
            2: [{ name: 'Flying Ant', hp: 90, speed: 3.0, damage: 14, size: 24, color: '#54a0ff', type: 'ant' }],
            3: [{ name: 'Lava Seal', hp: 130, speed: 2.8, damage: 18, size: 32, color: '#e74c3c', type: 'seal', ability: 'stun' }],
            4: [{ name: 'Paper Wasp', hp: 160, speed: 2.7, damage: 24, size: 32, color: '#ff9f43', type: 'wasp', ability: 'poison' }],
            5: [{ name: 'Dragonfly', hp: 190, speed: 2.9, damage: 28, size: 38, color: '#1dd1a1', type: 'dragonfly', ability: 'speed' }],
            6: [{ name: 'Hornet', hp: 240, speed: 2.6, damage: 34, size: 42, color: '#5f27cd', type: 'hornet', ability: 'rage' }],
            7: [{ name: 'Praying Mantis', hp: 280, speed: 2.4, damage: 42, size: 50, color: '#10ac84', type: 'mantis', ability: 'strike' }],
            8: [{ name: 'Damselfly', hp: 300, speed: 2.8, damage: 45, size: 52, color: '#222f3e', type: 'damselfly', ability: 'invisible' }],
            9: [{ name: 'Giant Hornet', hp: 380, speed: 2.5, damage: 55, size: 58, color: '#c0392b', type: 'gianthornet', ability: 'fear' }],
            10: [
                { name: 'Titan Beetle', hp: 520, speed: 2.0, damage: 75, size: 75, color: '#8e44ad', type: 'beetle', ability: 'shield' },
                { name: 'Emperor Scorpion', hp: 480, speed: 2.2, damage: 80, size: 72, color: '#16a085', type: 'scorpion', ability: 'venom' },
                { name: 'Phoenix Moth', hp: 450, speed: 2.4, damage: 70, size: 70, color: '#e67e22', type: 'phoenix', ability: 'regenerate' }
            ]
        };

        const XP_REQUIREMENTS = { 
            1: 0, 
            2: 200,
            3: 500,
            4: 1000,
            5: 1800,
            6: 3000,
            7: 4800,
            8: 7200,
            9: 10400,
            10: 15000
        };

        let canvas, ctx, camera = { x: 0, y: 0 };
        let player = null, playerName = '', bots = {}, foods = [], particles = [], statusEffects = [], damageTexts = [], xpOrbs = [];
        let gameRunning = false, mouseX = 0, mouseY = 0, lastUpdateTime = Date.now();
        let boostCharges = 0;
        let dashCooldown = 0;
        let finalStats = { tier: 1, xp: 0, animal: '' };
        let chatMessages = [];
        let chatOpen = false;
        let currentEvolutionTier = 0;

        class StatusEffect {
            constructor(target, type, duration) {
                this.target = target;
                this.type = type;
                this.duration = duration;
                this.maxDuration = duration;
                this.tickTimer = 0;
            }
            
            update(dt) {
                this.duration -= dt;
                
                if (this.type === 'stun') {
                    this.target.isStunned = true;
                    if (Math.random() < 0.1) {
                        particles.push(new Particle(
                            this.target.x + (Math.random() - 0.5) * this.target.size,
                            this.target.y - this.target.size,
                            '#ffff00', 'star'
                        ));
                    }
                } else if (this.type === 'poison') {
                    this.tickTimer += dt;
                    if (this.tickTimer >= 0.5) {
                        this.tickTimer = 0;
                        this.target.hp -= 8;
                        damageTexts.push(new DamageText(this.target.x, this.target.y - this.target.size - 20, 8, '#9b59b6'));
                        particles.push(new Particle(this.target.x, this.target.y, '#9b59b6', 'hit'));
                    }
                } else if (this.type === 'fear') {
                    this.target.isFeared = true;
                    this.target.fearSource = this.source;
                    
                    // Add visual effect for fear
                    if (Math.random() < 0.2) {
                        particles.push(new Particle(
                            this.target.x + (Math.random() - 0.5) * this.target.size,
                            this.target.y - this.target.size,
                            '#8e44ad', 'normal'
                        ));
                    }
                } else if (this.type === 'regenerate') {
                    this.tickTimer += dt;
                    if (this.tickTimer >= 0.5) {
                        this.tickTimer = 0;
                        this.target.heal(15);
                    }
                }
                
                if (this.duration <= 0) {
                    if (this.type === 'stun') this.target.isStunned = false;
                    if (this.type === 'fear') this.target.isFeared = false;
                    return false;
                }
                return true;
            }
        }

        class DamageText {
            constructor(x, y, amount, color = '#ff0000') {
                this.x = x + (Math.random() - 0.5) * 20;
                this.y = y;
                this.amount = amount;
                this.color = color;
                this.life = 1.5;
                this.vy = -1.5;
                this.scale = 1.2;
            }
            update(dt) {
                this.y += this.vy * 60 * dt;
                this.life -= dt;
                this.scale = Math.max(1, this.scale - dt * 0.5);
            }
            draw(ox, oy) {
                if (this.life <= 0) return;
                const alpha = Math.min(1, this.life * 2);
                ctx.globalAlpha = alpha;
                ctx.font = 'bold ' + Math.floor(16 * this.scale) + 'px Fredoka One';
                ctx.fillStyle = this.color;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.textAlign = 'center';
                const text = (this.amount > 0 ? '-' : '+') + Math.abs(Math.floor(this.amount));
                ctx.strokeText(text, this.x - ox, this.y - oy);
                ctx.fillText(text, this.x - ox, this.y - oy);
                ctx.globalAlpha = 1;
            }
        }

        class XpOrb {
            constructor(x, y, amount) {
                this.x = x + (Math.random() - 0.5) * 40;
                this.y = y + (Math.random() - 0.5) * 40;
                this.amount = amount;
                this.size = 8 + amount / 10;
                this.life = 15;
                this.floatOffset = Math.random() * 100;
            }
            update(dt) {
                this.life -= dt;
                if (player) {
                    const dist = Math.hypot(player.x - this.x, player.y - this.y);
                    if (dist < 150) {
                        const speed = Math.max(200, 400 - dist * 2);
                        const angle = Math.atan2(player.y - this.y, player.x - this.x);
                        this.x += Math.cos(angle) * speed * dt;
                        this.y += Math.sin(angle) * speed * dt;
                    }
                }
            }
            draw(ox, oy) {
                const yOff = Math.sin((Date.now() / 300) + this.floatOffset) * 3;
                const sx = this.x - ox;
                const sy = this.y - oy + yOff;
                
                ctx.fillStyle = '#f1c40f';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#f39c12';
                ctx.beginPath();
                ctx.arc(sx, sy, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(sx - this.size * 0.3, sy - this.size * 0.3, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color, type = 'normal') {
                this.x = x; this.y = y;
                this.type = type;
                if (type === 'fire') {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = -Math.random() * 6 - 2;
                    this.size = 4 + Math.random() * 6;
                    this.color = Math.random() > 0.5 ? '#ff6b35' : '#ffa500';
                } else if (type === 'hit') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.size = 2 + Math.random() * 3;
                    this.color = color;
                } else if (type === 'star') {
                    this.vx = (Math.random() - 0.5) * 3;
                    this.vy = -Math.random() * 2 - 1;
                    this.size = 4 + Math.random() * 3;
                    this.color = color;
                    this.rotation = Math.random() * Math.PI * 2;
                } else {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() - 0.5) * 8;
                    this.size = 3 + Math.random() * 5;
                    this.color = color;
                }
                this.life = 1.0;
                this.decay = 0.04 + Math.random() * 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.type === 'fire') {
                    this.vy += 0.1;
                    this.size *= 0.95;
                }
                if (this.type === 'star') {
                    this.rotation += 0.2;
                }
                this.vx *= 0.92;
                this.vy *= 0.92;
                this.life -= this.decay;
            }
            draw(ox, oy) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                
                if (this.type === 'star') {
                    ctx.save();
                    ctx.translate(this.x - ox, this.y - oy);
                    ctx.rotate(this.rotation);
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                        const x = Math.cos(angle) * this.size;
                        const y = Math.sin(angle) * this.size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                        const innerAngle = angle + Math.PI / 5;
                        ctx.lineTo(Math.cos(innerAngle) * this.size * 0.4, Math.sin(innerAngle) * this.size * 0.4);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x - ox, this.y - oy, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        }

        class Entity {
            constructor(x, y, name, animalIndex, isBot = false) {
                this.x = x; this.y = y; this.name = name;
                this.isBot = isBot;
                this.tier = 1;
                this.animalIndex = animalIndex;
                this.animalData = TIER_ANIMALS[1][animalIndex];
                this.updateStats();
                
                this.xp = 0;
                this.angle = 0;
                this.vx = 0; this.vy = 0;
                this.actualVx = 0; this.actualVy = 0;
                this.wingPhase = 0;
                this.abilityCooldown = 0;
                this.isDashing = false;
                this.dashTimer = 0;
                this.hitFlash = 0;
                this.inCombat = false;
                this.combatTarget = null;
                this.combatCooldown = 0;
                this.lastHitTime = 0;
                
                this.isStunned = false;
                this.isFeared = false;
                this.fearSource = null;
                this.isInvisible = false;
                this.invisibleTimer = 0;
                this.hasRage = false;
                this.rageTimer = 0;
                this.hasSpeedBoost = false;
                this.speedBoostTimer = 0;
                this.hasShield = false;
                this.shieldTimer = 0;
                this.isRegenerating = false;
                this.regenerateTimer = 0;
            }

            updateStats() {
                const hpPerc = this.maxHp ? (this.hp / this.maxHp) : 1;
                this.maxHp = this.animalData.hp;
                this.hp = this.maxHp * hpPerc;
                this.speed = this.animalData.speed;
                this.damage = this.animalData.damage;
                this.size = this.animalData.size;
                this.color = this.animalData.color;
                this.type = this.animalData.type;
            }

            update(dt) {
                if (this.invisibleTimer > 0) {
                    this.invisibleTimer -= dt;
                    if (this.invisibleTimer <= 0) this.isInvisible = false;
                }
                if (this.rageTimer > 0) {
                    this.rageTimer -= dt;
                    if (this.rageTimer <= 0) this.hasRage = false;
                }
                if (this.speedBoostTimer > 0) {
                    this.speedBoostTimer -= dt;
                    if (this.speedBoostTimer <= 0) this.hasSpeedBoost = false;
                }
                if (this.shieldTimer > 0) {
                    this.shieldTimer -= dt;
                    if (this.shieldTimer <= 0) this.hasShield = false;
                    if (Math.random() < 0.3) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push(new Particle(
                            this.x + Math.cos(angle) * this.size * 1.5,
                            this.y + Math.sin(angle) * this.size * 1.5,
                            '#f39c12', 'normal'
                        ));
                    }
                }
                if (this.regenerateTimer > 0) {
                    this.regenerateTimer -= dt;
                    if (this.regenerateTimer <= 0) this.isRegenerating = false;
                }
                
                if (this.isStunned) {
                    this.actualVx *= 0.8;
                    this.actualVy *= 0.8;
                    this.wingPhase += dt * 5;
                    if (this.abilityCooldown > 0) this.abilityCooldown -= dt;
                    if (this.hitFlash > 0) this.hitFlash -= dt * 3;
                    return;
                }
                
                if (this.isFeared && this.fearSource) {
                    const angle = Math.atan2(this.y - this.fearSource.y, this.x - this.fearSource.x);
                    this.vx = Math.cos(angle);
                    this.vy = Math.sin(angle);
                    this.angle = angle;
                }
                
                let speedMultiplier = this.isBot ? 1 : 1.4;
                if (this.hasSpeedBoost) speedMultiplier *= 2;
                let moveSpeed = this.speed * 60 * speedMultiplier;
                
                if (this.inCombat && !this.hasSpeedBoost) {
                    moveSpeed *= 0.3;
                }
                
                if (this.isDashing) {
                    this.dashTimer -= dt;
                    moveSpeed *= 3;
                    
                    // SCORPION BOOST CLAW ATTACK
                    if (this.type === 'scorpion' && !this.isBot) {
                        const clawRange = this.size * 2.5;
                        Object.values(bots).forEach(b => {
                            const dist = Math.hypot(b.x - this.x, b.y - this.y);
                            if (dist < clawRange) {
                                const clawDamage = this.damage * 1.5;
                                b.hp -= clawDamage;
                                b.onHit(clawDamage, this);
                                damageTexts.push(new DamageText(b.x, b.y - b.size - 20, clawDamage, '#16a085'));
                                // Broadcast bot damage to server (for ALL bots, server is authority)
if (socket && isConnected) {
    socket.emit('botDamaged', {
        botId: b.botId,
        damage: clawDamage,
        hp: b.hp,
        isDead: b.isDead
    });
}
                                for (let i = 0; i < 8; i++) {
                                    particles.push(new Particle(b.x, b.y, '#16a085', 'hit'));
                                }
                            }
                        });
                    }
                    
                    if (this.dashTimer <= 0) {
                        this.isDashing = false;
                    }
                }

                const targetVx = this.vx * moveSpeed;
                const targetVy = this.vy * moveSpeed;
                const accel = this.isDashing ? 20 : 10;
                this.actualVx += (targetVx - this.actualVx) * dt * accel;
                this.actualVy += (targetVy - this.actualVy) * dt * accel;

                this.x += this.actualVx * dt;
                this.y += this.actualVy * dt;
                
                this.x = Math.max(50, Math.min(CANVAS_WIDTH - 50, this.x));
                this.y = Math.max(50, Math.min(CANVAS_HEIGHT - 50, this.y));
                if (socket && isConnected && !this.isBot) {
                    socket.emit('playerMove', {
                        x: this.x,
                        y: this.y,
                        angle: this.angle,
                        vx: this.vx,
                        vy: this.vy
                    });
                }

                this.wingPhase += dt * (this.isDashing || this.hasSpeedBoost ? 30 : 18);
                
                if (this.abilityCooldown > 0) this.abilityCooldown -= dt;
                if (this.hitFlash > 0) this.hitFlash -= dt * 3;
                if (this.combatCooldown > 0) this.combatCooldown -= dt;
                
                if (Date.now() - this.lastHitTime > 500) {
                    this.inCombat = false;
                    this.combatTarget = null;
                }
                
                this.checkEvolution();
            }

            dash() {
                if (this.isStunned) return;
                if (boostCharges > 0 && !this.isDashing && dashCooldown <= 0) {
                    this.isDashing = true;
                    this.dashTimer = 0.2;
                    boostCharges--;
                    dashCooldown = 0.3;
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(this.x, this.y, '#ffffff'));
                    }
                }
            }

            clearPowerups() {
                this.isInvisible = false;
                this.invisibleTimer = 0;
                this.hasRage = false;
                this.rageTimer = 0;
                this.hasSpeedBoost = false;
                this.speedBoostTimer = 0;
                this.hasShield = false;
                this.shieldTimer = 0;
                this.isRegenerating = false;
                this.regenerateTimer = 0;
            }

            useAbility() {
                if (this.isStunned) return false;
                if (!this.animalData.ability) return false;
                if (this.abilityCooldown > 0) return false;
                
                const ability = this.animalData.ability;
                const abilityInfo = ABILITIES[ability];
                this.abilityCooldown = abilityInfo.cooldown;
                
                const range = 180;
                const targets = Object.values(bots).filter(b => Math.hypot(b.x - this.x, b.y - this.y) < range);
                
                switch(ability) {
                    case 'stun':
                        targets.forEach(b => {
                            statusEffects.push(new StatusEffect(b, 'stun', 3));
                            for (let i = 0; i < 10; i++) {
                                particles.push(new Particle(b.x, b.y, '#ffff00', 'star'));
                            }
                        });
                        for (let i = 0; i < 30; i++) {
                            const angle = (Math.PI * 2 / 30) * i;
                            particles.push(new Particle(
                                this.x + Math.cos(angle) * range * 0.5,
                                this.y + Math.sin(angle) * range * 0.5,
                                '#e74c3c', 'fire'
                            ));
                        }
                        showToast('Lava Stun Activated!', 'success');
                        sendChatMessage('used Lava Stun!');
                        break;
                        
                    case 'poison':
                        targets.forEach(b => {
                            statusEffects.push(new StatusEffect(b, 'poison', 5));
                            for (let i = 0; i < 8; i++) {
                                particles.push(new Particle(b.x, b.y, '#9b59b6', 'hit'));
                            }
                        });
                        showToast('Poison Sting!', 'success');
                        sendChatMessage('used Poison Sting!');
                        break;
                        
                    case 'speed':
                        this.hasSpeedBoost = true;
                        this.speedBoostTimer = 4;
                        for (let i = 0; i < 15; i++) {
                            particles.push(new Particle(this.x, this.y, '#3498db', 'normal'));
                        }
                        showToast('Swift Flight!', 'success');
                        sendChatMessage('activated Swift Flight!');
                        break;
                        
                    case 'rage':
                        this.hasRage = true;
                        this.rageTimer = 5;
                        for (let i = 0; i < 20; i++) {
                            particles.push(new Particle(this.x, this.y, '#e74c3c', 'fire'));
                        }
                        showToast('Fury Activated!', 'success');
                        sendChatMessage('entered Fury mode!');
                        break;
                        
                    case 'strike':
                        this.isDashing = true;
                        this.dashTimer = 0.3;
                        const strikeTargets = Object.values(bots).filter(b => {
                            const dist = Math.hypot(b.x - this.x, b.y - this.y);
                            return dist < 150;
                        });
                        strikeTargets.forEach(b => {
                            const strikeDamage = this.damage * 3;
                            b.hp -= strikeDamage;
                            // Broadcast bot damage to server (for ALL bots, server is authority)
if (socket && isConnected) {
    socket.emit('botDamaged', {
        botId: b.botId,
        damage: strikeDamage,
        hp: b.hp,
        isDead: b.isDead
    });
}
                            b.onHit(strikeDamage, this);
                            for (let i = 0; i < 10; i++) {
                                particles.push(new Particle(b.x, b.y, '#27ae60', 'hit'));
                            }
                        });
                        for (let i = 0; i < 15; i++) {
                            particles.push(new Particle(this.x, this.y, '#27ae60', 'normal'));
                        }
                        showToast('Ambush Strike!', 'success');
                        sendChatMessage('used Ambush Strike!');
                        break;
                        
                    case 'invisible':
                        this.isInvisible = true;
                        this.invisibleTimer = 4;
                        for (let i = 0; i < 20; i++) {
                            particles.push(new Particle(this.x, this.y, '#95a5a6', 'normal'));
                        }
                        showToast('Camouflage!', 'success');
                        sendChatMessage('used Camouflage!');
                        break;
                        
                    case 'fear':
                        targets.forEach(b => {
                            const effect = new StatusEffect(b, 'fear', 3);
                            effect.source = this;
                            statusEffects.push(effect);
                            for (let i = 0; i < 8; i++) {
                                particles.push(new Particle(b.x, b.y, '#8e44ad', 'normal'));
                            }
                        });
                        
                        // IMPROVED FEAR ANIMATION
                        for (let i = 0; i < 40; i++) {
                            const angle = (Math.PI * 2 / 40) * i;
                            particles.push(new Particle(
                                this.x + Math.cos(angle) * range * 0.6,
                                this.y + Math.sin(angle) * range * 0.6,
                                '#8e44ad', 'star'
                            ));
                        }
                        
                        showToast('Intimidate!', 'success');
                        sendChatMessage('intimidated enemies!');
                        break;
                        
                    case 'shield':
                        this.hasShield = true;
                        this.shieldTimer = 3;
                        for (let i = 0; i < 25; i++) {
                            const angle = (Math.PI * 2 / 25) * i;
                            particles.push(new Particle(
                                this.x + Math.cos(angle) * this.size,
                                this.y + Math.sin(angle) * this.size,
                                '#f39c12', 'normal'
                            ));
                        }
                        showToast('Iron Shell!', 'success');
                        sendChatMessage('activated Iron Shell!');
                        break;
                        
                    case 'venom':
                        targets.forEach(b => {
                            statusEffects.push(new StatusEffect(b, 'poison', 6));
                            const damage = this.damage * 1.5;
                            b.hp -= damage;
                            // Broadcast bot damage to server (for ALL bots, server is authority)
if (socket && isConnected) {
    socket.emit('botDamaged', {
        botId: b.botId,
        damage: damage,
        hp: b.hp,
        isDead: b.isDead
    });
}
                            b.onHit(damage, this);
                        });
                        for (let i = 0; i < 40; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * range;
                            particles.push(new Particle(
                                this.x + Math.cos(angle) * dist,
                                this.y + Math.sin(angle) * dist,
                                '#16a085', 'hit'
                            ));
                        }
                        showToast('Venom Blast!', 'success');
                        sendChatMessage('unleashed Venom Blast!');
                        break;
                        
                    case 'regenerate':
                        this.isRegenerating = true;
                        this.regenerateTimer = 6;
                        statusEffects.push(new StatusEffect(this, 'regenerate', 6));
                        for (let i = 0; i < 20; i++) {
                            particles.push(new Particle(this.x, this.y, '#27ae60', 'normal'));
                        }
                        showToast('Regeneration!', 'success');
                        sendChatMessage('activated Regeneration!');
                        break;
                }
                
                return true;
            }

            onHit(damage, attacker) {
                if (this.hasShield) return;
                this.hitFlash = 1;
                this.inCombat = true;
                this.combatTarget = attacker;
                this.lastHitTime = Date.now();
                damageTexts.push(new DamageText(this.x, this.y - this.size - 30, damage, '#ff4444'));
                for (let i = 0; i < 4; i++) {
                    particles.push(new Particle(this.x, this.y, '#ffffff', 'hit'));
                }
            }

            heal(amount) {
                const healAmount = Math.min(amount, this.maxHp - this.hp);
                if (healAmount > 0) {
                    this.hp += healAmount;
                    damageTexts.push(new DamageText(this.x, this.y - this.size - 30, -healAmount, '#2ecc71'));
                    for (let i = 0; i < 3; i++) {
                        particles.push(new Particle(this.x, this.y, '#2ecc71', 'normal'));
                    }
                }
            }

            checkEvolution() {
                for (let t = 10; t >= 1; t--) {
                    if (this.xp >= XP_REQUIREMENTS[t] && this.tier < t) {
                        if (this === player) {
                            // This check prevents the menu from refreshing 60 times a second
                            if (currentEvolutionTier !== t) {
                                currentEvolutionTier = t;
                                showEvolutionBar(t);
                            }
                        } else {
                            this.evolve(t);
                        }
                        break;
                    }
                }
                // Send XP update to server
                if (socket && isConnected && !this.isBot) {
                    socket.emit('playerUpdate', {
                        size: this.size,
                        tier: this.tier,
                        hp: this.hp,
                        xp: this.xp,
                        color: this.color,
                        animalType: this.animalData.name,
                        animalIndex: this.animalIndex
                    });
                }
            }

            evolve(newTier, animalIndex = null) {
                this.tier = newTier;
                const tierAnimals = TIER_ANIMALS[newTier];
                
                if (animalIndex !== null) {
                    this.animalIndex = animalIndex;
                } else {
                    this.animalIndex = Math.floor(Math.random() * tierAnimals.length);
                }
                
                this.animalData = tierAnimals[this.animalIndex];
                this.updateStats();
                this.hp = this.maxHp;
                this.clearPowerups();
                
                for (let i = 0; i < 20; i++) particles.push(new Particle(this.x, this.y, '#ffffff'));
                
                if (this === player) {
                    showToast('Evolved to ' + this.animalData.name + '!', 'success');
                    sendChatMessage('evolved to ' + this.animalData.name + '!');
                    if (this.animalData.ability) {
                        document.getElementById('ability-display').style.display = 'block';
                    }
                    hideEvolutionBar();
                }
            }

            takeDamage(amount) {
                if (this.hasShield) return false;
                this.hp -= amount;
                return this.hp <= 0;
            }

            draw(ox, oy, isSelf = false) {
                if (this.isInvisible && !isSelf) return;
                
                const sx = this.x - ox;
                const sy = this.y - oy;
                
                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(this.angle + Math.PI/2);
                
                if (this.isInvisible) {
                    ctx.globalAlpha = 0.3;
                }
                
                if (this.hitFlash > 0) {
                    ctx.globalAlpha = Math.max(ctx.globalAlpha, 0.6 + this.hitFlash * 0.4);
                }
                
                if (this.isStunned) {
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.2;
                }
                
                if (this.hasRage) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#e74c3c';
                }
                
                if (this.hasSpeedBoost) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#3498db';
                }
                
                if (this.hasShield) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#f39c12';
                }
                
                if (this.isRegenerating) {
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = '#27ae60';
                }
                
                this.drawAnimalByType();
                
                ctx.restore();
                
                if (this.hasShield) {
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 200) * 0.3;
                    ctx.beginPath();
                    ctx.arc(sx, sy, this.size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                this.drawName(sx, sy - this.size - 55, isSelf);
                this.drawHpBar(sx, sy - this.size - 40);
                
                if (this.isStunned) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 12px Fredoka One';
                    ctx.textAlign = 'center';
                    ctx.fillText('STUNNED', sx, sy - this.size - 65);
                }
                
                if (this.isFeared) {
                    ctx.fillStyle = '#8e44ad';
                    ctx.font = 'bold 12px Fredoka One';
                    ctx.textAlign = 'center';
                    ctx.fillText('FEARED', sx, sy - this.size - 65);
                }
            }

            drawAnimalByType() {
                const s = this.size;
                const c = this.color;
                const wingOffset = 0;

                ctx.save();
                
                switch(this.type) {
                    case 'fly': this.drawFly(s, c, wingOffset); break;
                    case 'mosquito': this.drawMosquito(s, c, wingOffset); break;
                    case 'ant': this.drawAnt(s, c, wingOffset); break;
                    case 'seal': this.drawLavaSeal(s, c, wingOffset); break;
                    case 'wasp': this.drawWasp(s, c, wingOffset); break;
                    case 'dragonfly': this.drawDragonfly(s, c, wingOffset); break;
                    case 'hornet': this.drawHornet(s, c, wingOffset); break;
                    case 'mantis': this.drawMantis(s, c, wingOffset); break;
                    case 'damselfly': this.drawDamselfly(s, c, wingOffset); break;
                    case 'gianthornet': this.drawGiantHornet(s, c, wingOffset); break;
                    case 'beetle': this.drawBeetle(s, c, wingOffset); break;
                    case 'scorpion': this.drawScorpion(s, c, wingOffset); break;
                    case 'phoenix': this.drawPhoenix(s, c, wingOffset); break;
                    default: this.drawFly(s, c, wingOffset);
                }
                
                ctx.restore();
            }

            drawFly(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(200, 220, 255, 0.6)';
                ctx.beginPath();
                ctx.ellipse(-s*0.6, -s*0.1, s*0.8, s*0.35, -0.3 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.6, -s*0.1, s*0.8, s*0.35, 0.3 + wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, 0, s*0.4, s*0.5, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(0, -s*0.5, s*0.3, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.arc(-s*0.15, -s*0.55, s*0.12, 0, Math.PI*2);
                ctx.arc(s*0.15, -s*0.55, s*0.12, 0, Math.PI*2);
                ctx.fill();
            }

            drawMosquito(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(200, 220, 255, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-s*0.5, 0, s*0.7, s*0.2, -0.2 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.5, 0, s*0.7, s*0.2, 0.2 + wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.4, s*0.2, s*0.6, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(0, -s*0.1, s*0.25, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(0, -s*0.4, s*0.18, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = c;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -s*0.55);
                ctx.lineTo(0, -s*1.1);
                ctx.stroke();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-s*0.08, -s*0.45, s*0.06, 0, Math.PI*2);
                ctx.arc(s*0.08, -s*0.45, s*0.06, 0, Math.PI*2);
                ctx.fill();
            }

            drawAnt(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(180, 200, 230, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-s*0.5, -s*0.2, s*0.9, s*0.25, -0.2 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.5, -s*0.2, s*0.9, s*0.25, 0.2 + wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.5, s*0.35, s*0.45, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.ellipse(0, 0, s*0.2, s*0.25, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(0, -s*0.4, s*0.22, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = c;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-s*0.1, -s*0.55);
                ctx.quadraticCurveTo(-s*0.3, -s*0.8, -s*0.2, -s*0.9);
                ctx.moveTo(s*0.1, -s*0.55);
                ctx.quadraticCurveTo(s*0.3, -s*0.8, s*0.2, -s*0.9);
                ctx.stroke();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-s*0.1, -s*0.42, s*0.06, 0, Math.PI*2);
                ctx.arc(s*0.1, -s*0.42, s*0.06, 0, Math.PI*2);
                ctx.fill();
            }

            drawLavaSeal(s, c, wingOffset) {
                const gradient = ctx.createRadialGradient(0, 0, s*0.2, 0, 0, s*1.5);
                gradient.addColorStop(0, 'rgba(255, 100, 50, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 100, 50, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, s*1.5, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.2, s*0.6, s*0.8, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-s*0.2, s*0.1);
                ctx.lineTo(-s*0.3, s*0.4);
                ctx.lineTo(-s*0.15, s*0.6);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.2, s*0.0);
                ctx.lineTo(s*0.35, s*0.3);
                ctx.lineTo(s*0.2, s*0.5);
                ctx.stroke();

                ctx.fillStyle = '#ffa500';
                ctx.beginPath();
                ctx.arc(-s*0.25, s*0.35, s*0.1, 0, Math.PI*2);
                ctx.arc(s*0.25, s*0.25, s*0.08, 0, Math.PI*2);
                ctx.arc(0, s*0.5, s*0.07, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = darkenColor(c, 15);
                ctx.beginPath();
                ctx.ellipse(-s*0.55, s*0.1, s*0.25, s*0.12, -0.5 + wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.55, s*0.1, s*0.25, s*0.12, 0.5 - wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.ellipse(-s*0.2, s*0.9, s*0.15, s*0.1, 0.3, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.2, s*0.9, s*0.15, s*0.1, -0.3, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(0, -s*0.5, s*0.4, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = lightenColor(c, 15);
                ctx.beginPath();
                ctx.ellipse(0, -s*0.35, s*0.2, s*0.15, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.ellipse(0, -s*0.3, s*0.08, s*0.05, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#ff6b35';
                ctx.beginPath();
                ctx.arc(-s*0.18, -s*0.55, s*0.1, 0, Math.PI*2);
                ctx.arc(s*0.18, -s*0.55, s*0.1, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#ff3300';
                ctx.beginPath();
                ctx.arc(-s*0.18, -s*0.55, s*0.04, 0, Math.PI*2);
                ctx.arc(s*0.18, -s*0.55, s*0.04, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-s*0.15, -s*0.32);
                ctx.lineTo(-s*0.4, -s*0.35);
                ctx.moveTo(-s*0.15, -s*0.28);
                ctx.lineTo(-s*0.4, -s*0.25);
                ctx.moveTo(s*0.15, -s*0.32);
                ctx.lineTo(s*0.4, -s*0.35);
                ctx.moveTo(s*0.15, -s*0.28);
                ctx.lineTo(s*0.4, -s*0.25);
                ctx.stroke();
            }

            drawWasp(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(255, 240, 200, 0.6)';
                ctx.beginPath();
                ctx.ellipse(-s*0.6, -s*0.15, s*1, s*0.3, -0.25 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.6, -s*0.15, s*1, s*0.3, 0.25 + wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.5, s*0.3, s*0.55, 0, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = '#2c3e50';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, s*0.3 + i*s*0.18, s*0.25, s*0.04, 0, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.moveTo(-s*0.05, s*1);
                ctx.lineTo(0, s*1.3);
                ctx.lineTo(s*0.05, s*1);
                ctx.fill();

                ctx.fillStyle = lightenColor(c, 10);
                ctx.beginPath();
                ctx.ellipse(0, 0, s*0.28, s*0.3, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(0, -s*0.4, s*0.22, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-s*0.1, -s*0.42, s*0.08, 0, Math.PI*2);
                ctx.arc(s*0.1, -s*0.42, s*0.08, 0, Math.PI*2);
                ctx.fill();
            }

            drawDragonfly(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(150, 220, 255, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-s*0.7, -s*0.3, s*1.2, s*0.25, -0.15 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.7, -s*0.3, s*1.2, s*0.25, 0.15 + wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(-s*0.6, s*0.1, s*1, s*0.22, 0.1 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.6, s*0.1, s*1, s*0.22, -0.1 + wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.8, s*0.12, s*0.7, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.ellipse(0, 0, s*0.25, s*0.3, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(0, -s*0.4, s*0.25, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(-s*0.15, -s*0.42, s*0.12, 0, Math.PI*2);
                ctx.arc(s*0.15, -s*0.42, s*0.12, 0, Math.PI*2);
                ctx.fill();
            }

            drawHornet(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(255, 230, 180, 0.7)';
                ctx.beginPath();
                ctx.ellipse(-s*0.7, -s*0.15, s*1.2, s*0.4, -0.25 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.7, -s*0.15, s*1.2, s*0.4, 0.25 + wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.5, s*0.38, s*0.65, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#2c3e50';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, s*0.25 + i*s*0.18, s*0.32 - i*0.02, s*0.06, 0, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.moveTo(0, s*1.0);
                ctx.lineTo(-s*0.08, s*0.95);
                ctx.lineTo(s*0.08, s*0.95);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(0, s*1.0);
                ctx.lineTo(0, s*1.2);
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.fillStyle = darkenColor(c, 10);
                ctx.beginPath();
                ctx.ellipse(0, 0, s*0.32, s*0.35, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(0, -s*0.45, s*0.3, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(-s*0.15, -s*0.48, s*0.12, 0, Math.PI*2);
                ctx.arc(s*0.15, -s*0.48, s*0.12, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.arc(-s*0.17, -s*0.5, s*0.05, 0, Math.PI*2);
                ctx.arc(s*0.13, -s*0.5, s*0.05, 0, Math.PI*2);
                ctx.fill();
                
                ctx.strokeStyle = c;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-s*0.12, -s*0.6);
                ctx.quadraticCurveTo(-s*0.25, -s*0.75, -s*0.2, -s*0.85);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.12, -s*0.6);
                ctx.quadraticCurveTo(s*0.25, -s*0.75, s*0.2, -s*0.85);
                ctx.stroke();
            }

            drawMantis(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(80, 180, 120, 0.4)';
                ctx.beginPath();
                ctx.ellipse(-s*0.25, s*0.4, s*0.5, s*0.15, 0.2 - wingOffset*0.3, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.25, s*0.4, s*0.5, s*0.15, -0.2 + wingOffset*0.3, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.7, s*0.22, s*0.55, 0, 0, Math.PI*2);
                ctx.fill();
                
                ctx.strokeStyle = darkenColor(c, 15);
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, s*0.45 + i*s*0.15, s*0.18, s*0.02, 0, 0, Math.PI*2);
                    ctx.stroke();
                }

                ctx.fillStyle = lightenColor(c, 8);
                ctx.beginPath();
                ctx.ellipse(0, s*0.05, s*0.18, s*0.35, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = c;
                ctx.lineWidth = s*0.06;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(-s*0.15, -s*0.15);
                ctx.lineTo(-s*0.35, -s*0.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-s*0.35, -s*0.5);
                ctx.lineTo(-s*0.15, -s*0.8);
                ctx.stroke();
                ctx.lineWidth = s*0.04;
                ctx.beginPath();
                ctx.moveTo(-s*0.15, -s*0.8);
                ctx.lineTo(-s*0.08, -s*0.9);
                ctx.moveTo(-s*0.15, -s*0.8);
                ctx.lineTo(-s*0.22, -s*0.88);
                ctx.stroke();
                
                ctx.lineWidth = s*0.06;
                ctx.beginPath();
                ctx.moveTo(s*0.15, -s*0.15);
                ctx.lineTo(s*0.35, -s*0.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.35, -s*0.5);
                ctx.lineTo(s*0.15, -s*0.8);
                ctx.stroke();
                ctx.lineWidth = s*0.04;
                ctx.beginPath();
                ctx.moveTo(s*0.15, -s*0.8);
                ctx.lineTo(s*0.08, -s*0.9);
                ctx.moveTo(s*0.15, -s*0.8);
                ctx.lineTo(s*0.22, -s*0.88);
                ctx.stroke();

                ctx.lineWidth = s*0.04;
                ctx.beginPath();
                ctx.moveTo(-s*0.12, s*0.1);
                ctx.lineTo(-s*0.4, s*0.3);
                ctx.lineTo(-s*0.5, s*0.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.12, s*0.1);
                ctx.lineTo(s*0.4, s*0.3);
                ctx.lineTo(s*0.5, s*0.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-s*0.1, s*0.3);
                ctx.lineTo(-s*0.35, s*0.5);
                ctx.lineTo(-s*0.45, s*0.7);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.1, s*0.3);
                ctx.lineTo(s*0.35, s*0.5);
                ctx.lineTo(s*0.45, s*0.7);
                ctx.stroke();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.moveTo(0, -s*0.55);
                ctx.lineTo(-s*0.22, -s*0.25);
                ctx.lineTo(s*0.22, -s*0.25);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.ellipse(-s*0.12, -s*0.38, s*0.1, s*0.08, -0.3, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.12, -s*0.38, s*0.1, s*0.08, 0.3, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-s*0.14, -s*0.4, s*0.03, 0, Math.PI*2);
                ctx.arc(s*0.1, -s*0.4, s*0.03, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = c;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-s*0.05, -s*0.5);
                ctx.quadraticCurveTo(-s*0.15, -s*0.7, -s*0.1, -s*0.8);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.05, -s*0.5);
                ctx.quadraticCurveTo(s*0.15, -s*0.7, s*0.1, -s*0.8);
                ctx.stroke();
            }

            drawDamselfly(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(100, 150, 200, 0.4)';
                ctx.beginPath();
                ctx.ellipse(-s*0.4, -s*0.2, s*1.3, s*0.18, -0.1 - wingOffset*0.5, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.4, -s*0.2, s*1.3, s*0.18, 0.1 + wingOffset*0.5, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.9, s*0.08, s*0.8, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.ellipse(0, 0, s*0.18, s*0.25, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(0, -s*0.35, s*0.18, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(-s*0.08, -s*0.38, s*0.08, 0, Math.PI*2);
                ctx.arc(s*0.08, -s*0.38, s*0.08, 0, Math.PI*2);
                ctx.fill();
            }

            drawGiantHornet(s, c, wingOffset) {
                ctx.fillStyle = 'rgba(255, 220, 150, 0.7)';
                ctx.beginPath();
                ctx.ellipse(-s*0.75, -s*0.15, s*1.4, s*0.45, -0.2 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s*0.75, -s*0.15, s*1.4, s*0.45, 0.2 + wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.6, s*0.48, s*0.72, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#2c3e50';
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, s*0.22 + i*s*0.2, s*0.42 - i*0.03, s*0.07, 0, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.moveTo(0, s*1.2);
                ctx.lineTo(-s*0.12, s*1.05);
                ctx.lineTo(s*0.12, s*1.05);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, s*1.2);
                ctx.lineTo(0, s*1.4);
                ctx.stroke();

                ctx.fillStyle = darkenColor(c, 12);
                ctx.beginPath();
                ctx.ellipse(0, 0, s*0.38, s*0.42, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(0, -s*0.52, s*0.35, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.moveTo(-s*0.18, -s*0.38);
                ctx.lineTo(-s*0.28, -s*0.25);
                ctx.lineTo(-s*0.12, -s*0.32);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(s*0.18, -s*0.38);
                ctx.lineTo(s*0.28, -s*0.25);
                ctx.lineTo(s*0.12, -s*0.32);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.arc(-s*0.16, -s*0.56, s*0.13, 0, Math.PI*2);
                ctx.arc(s*0.16, -s*0.56, s*0.13, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.arc(-s*0.16, -s*0.56, s*0.08, 0, Math.PI*2);
                ctx.arc(s*0.16, -s*0.56, s*0.08, 0, Math.PI*2);
                ctx.fill();
                
                ctx.strokeStyle = c;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-s*0.15, -s*0.7);
                ctx.quadraticCurveTo(-s*0.3, -s*0.85, -s*0.22, -s*0.95);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.15, -s*0.7);
                ctx.quadraticCurveTo(s*0.3, -s*0.85, s*0.22, -s*0.95);
                ctx.stroke();
            }

            drawBeetle(s, c, wingOffset) {
                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.3, s*0.55, s*0.7, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = darkenColor(c, 30);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -s*0.3);
                ctx.lineTo(0, s*0.9);
                ctx.stroke();

                ctx.fillStyle = lightenColor(c, 20);
                ctx.beginPath();
                ctx.ellipse(-s*0.25, s*0.1, s*0.15, s*0.25, 0.3, 0, Math.PI*2);
                ctx.ellipse(s*0.25, s*0.1, s*0.15, s*0.25, -0.3, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = darkenColor(c, 15);
                ctx.beginPath();
                ctx.ellipse(0, -s*0.25, s*0.4, s*0.3, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(0, -s*0.6, s*0.28, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = darkenColor(c, 25);
                ctx.beginPath();
                ctx.moveTo(0, -s*0.85);
                ctx.lineTo(-s*0.08, -s*0.65);
                ctx.lineTo(s*0.08, -s*0.65);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = darkenColor(c, 30);
                ctx.lineWidth = s*0.06;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-s*0.15, -s*0.5);
                ctx.quadraticCurveTo(-s*0.35, -s*0.7, -s*0.25, -s*0.85);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.15, -s*0.5);
                ctx.quadraticCurveTo(s*0.35, -s*0.7, s*0.25, -s*0.85);
                ctx.stroke();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-s*0.12, -s*0.62, s*0.06, 0, Math.PI*2);
                ctx.arc(s*0.12, -s*0.62, s*0.06, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = darkenColor(c, 20);
                ctx.lineWidth = s*0.05;
                for (let i = 0; i < 3; i++) {
                    const y = -s*0.1 + i * s*0.25;
                    ctx.beginPath();
                    ctx.moveTo(-s*0.4, y);
                    ctx.lineTo(-s*0.8, y + s*0.2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(s*0.4, y);
                    ctx.lineTo(s*0.8, y + s*0.2);
                    ctx.stroke();
                }
            }
            
            drawScorpion(s, c, wingOffset) {
                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, s*0.3, s*0.5, s*0.6, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = darkenColor(c, 10);
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, s*0.1 + i*s*0.15, s*0.42 - i*0.05, s*0.08, 0, 0, Math.PI*2);
                    ctx.fill();
                }

                const tailSegs = 5;
                for (let i = 0; i < tailSegs; i++) {
                    const prog = i / tailSegs;
                    const yPos = s*0.85 + i*s*0.12;
                    const xOff = Math.sin(prog * Math.PI) * s*0.2;
                    const segSize = s*0.15 - i*0.02;
                    
                    ctx.fillStyle = i % 2 === 0 ? c : darkenColor(c, 15);
                    ctx.beginPath();
                    ctx.ellipse(xOff, yPos, segSize, s*0.1, 0, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.fillStyle = '#e74c3c';
                const stingerX = Math.sin((tailSegs / tailSegs) * Math.PI) * s*0.2;
                ctx.beginPath();
                ctx.moveTo(stingerX, s*1.45);
                ctx.lineTo(stingerX - s*0.08, s*1.35);
                ctx.lineTo(stingerX + s*0.08, s*1.35);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = c;
                ctx.lineWidth = s*0.12;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(-s*0.25, -s*0.2);
                ctx.lineTo(-s*0.6, -s*0.4);
                ctx.stroke();
                
                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(-s*0.6, -s*0.4, s*0.15, 0, Math.PI*2);
                ctx.fill();
                
                ctx.strokeStyle = darkenColor(c, 20);
                ctx.lineWidth = s*0.05;
                ctx.beginPath();
                ctx.moveTo(-s*0.65, -s*0.5);
                ctx.lineTo(-s*0.75, -s*0.65);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-s*0.55, -s*0.5);
                ctx.lineTo(-s*0.58, -s*0.68);
                ctx.stroke();

                ctx.strokeStyle = c;
                ctx.lineWidth = s*0.12;
                ctx.beginPath();
                ctx.moveTo(s*0.25, -s*0.2);
                ctx.lineTo(s*0.6, -s*0.4);
                ctx.stroke();
                
                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(s*0.6, -s*0.4, s*0.15, 0, Math.PI*2);
                ctx.fill();
                
                ctx.strokeStyle = darkenColor(c, 20);
                ctx.lineWidth = s*0.05;
                ctx.beginPath();
                ctx.moveTo(s*0.65, -s*0.5);
                ctx.lineTo(s*0.75, -s*0.65);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.55, -s*0.5);
                ctx.lineTo(s*0.58, -s*0.68);
                ctx.stroke();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, -s*0.35, s*0.35, s*0.25, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(-s*0.15, -s*0.4, s*0.08, 0, Math.PI*2);
                ctx.arc(s*0.15, -s*0.4, s*0.08, 0, Math.PI*2);
                ctx.fill();
                
                ctx.strokeStyle = darkenColor(c, 15);
                ctx.lineWidth = s*0.06;
                for (let i = 0; i < 4; i++) {
                    const yPos = s*0.05 + i*s*0.15;
                    ctx.beginPath();
                    ctx.moveTo(-s*0.35, yPos);
                    ctx.lineTo(-s*0.65, yPos + s*0.15);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(s*0.35, yPos);
                    ctx.lineTo(s*0.65, yPos + s*0.15);
                    ctx.stroke();
                }
            }

            drawPhoenix(s, c, wingOffset) {
                const wingGrad1 = ctx.createRadialGradient(-s*0.7, 0, 0, -s*0.7, 0, s*1.3);
                wingGrad1.addColorStop(0, '#ff6b35');
                wingGrad1.addColorStop(0.5, '#f7931e');
                wingGrad1.addColorStop(1, 'rgba(255, 107, 53, 0.3)');
                
                ctx.fillStyle = wingGrad1;
                ctx.beginPath();
                ctx.ellipse(-s*0.7, 0, s*1.3, s*0.6, -0.3 - wingOffset, 0, Math.PI*2);
                ctx.fill();
                
                const wingGrad2 = ctx.createRadialGradient(s*0.7, 0, 0, s*0.7, 0, s*1.3);
                wingGrad2.addColorStop(0, '#ff6b35');
                wingGrad2.addColorStop(0.5, '#f7931e');
                wingGrad2.addColorStop(1, 'rgba(255, 107, 53, 0.3)');
                
                ctx.fillStyle = wingGrad2;
                ctx.beginPath();
                ctx.ellipse(s*0.7, 0, s*1.3, s*0.6, 0.3 + wingOffset, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.ellipse(-s*0.7, 0, s*0.4 + i*s*0.3, s*0.2 + i*s*0.15, -0.3 - wingOffset, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(s*0.7, 0, s*0.4 + i*s*0.3, s*0.2 + i*s*0.15, 0.3 + wingOffset, 0, Math.PI*2);
                    ctx.stroke();
                }

                const bodyGrad = ctx.createLinearGradient(0, -s*0.5, 0, s*0.8);
                bodyGrad.addColorStop(0, c);
                bodyGrad.addColorStop(1, darkenColor(c, 20));
                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.ellipse(0, s*0.4, s*0.25, s*0.7, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = lightenColor(c, 15);
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, s*0.1 + i*s*0.1, s*0.2, s*0.05, 0, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.ellipse(0, -s*0.1, s*0.22, s*0.3, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(0, -s*0.5, s*0.2, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#f39c12';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f39c12';
                ctx.beginPath();
                ctx.arc(-s*0.1, -s*0.52, s*0.08, 0, Math.PI*2);
                ctx.arc(s*0.1, -s*0.52, s*0.08, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.strokeStyle = c;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-s*0.08, -s*0.65);
                ctx.quadraticCurveTo(-s*0.25, -s*0.85, -s*0.18, -s*0.95);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s*0.08, -s*0.65);
                ctx.quadraticCurveTo(s*0.25, -s*0.85, s*0.18, -s*0.95);
                ctx.stroke();
                
                ctx.fillStyle = lightenColor(c, 20);
                ctx.beginPath();
                ctx.arc(-s*0.18, -s*0.95, s*0.08, 0, Math.PI*2);
                ctx.arc(s*0.18, -s*0.95, s*0.08, 0, Math.PI*2);
                ctx.fill();
            }

            drawHpBar(x, y) {
                const w = 50; const h = 8;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(x - w/2, y, w, h, 4);
                ctx.fill();
                ctx.stroke();
                
                const pct = Math.max(0, this.hp / this.maxHp);
                const gradient = ctx.createLinearGradient(x - w/2, y, x + w/2, y);
                if (pct > 0.5) {
                    gradient.addColorStop(0, '#2ecc71');
                    gradient.addColorStop(1, '#27ae60');
                } else if (pct > 0.25) {
                    gradient.addColorStop(0, '#f1c40f');
                    gradient.addColorStop(1, '#f39c12');
                } else {
                    gradient.addColorStop(0, '#e74c3c');
                    gradient.addColorStop(1, '#c0392b');
                }
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.roundRect(x - w/2 + 2, y + 2, (w - 4) * pct, h - 4, 2);
                ctx.fill();
            }

            drawName(x, y, isSelf) {
                ctx.fillStyle = '#000000';
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = 3;
                ctx.font = 'bold 14px Nunito';
                ctx.textAlign = 'center';
                
                const displayName = this.name || (this.isBot ? 'Bot' : '');
                ctx.strokeText(displayName, x, y);
                ctx.fillText(displayName, x, y);
                
                ctx.font = 'bold 11px Nunito';
                ctx.strokeText(Math.floor(this.xp) + ' XP', x, y + 13);
                ctx.fillText(Math.floor(this.xp) + ' XP', x, y + 13);
            }
        }

        class Bot extends Entity {
            constructor(x, y, botId = null) {
                super(x, y, '', Math.floor(Math.random() * 3), true);
                this.botId = botId || ('bot_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                this.targetX = x;
                this.targetY = y;
                this.wanderTimer = 0;
                this.aggroTarget = null;
                this.aggroTimer = 0;
                this.respawnTimer = 0;
                this.isDead = false;
                this.isRemote = false; // Track if this bot is from another player
            }

            update(dt) {
                // RESPAWN MECHANIC
                if (this.isDead) {
                    this.respawnTimer -= dt;
                    if (this.respawnTimer <= 0) {
                        this.respawn();
                    }
                    return;
                }
                
                if (this.isStunned) {
                    this.actualVx *= 0.8;
                    this.actualVy *= 0.8;
                    this.wingPhase += dt * 5;
                    if (this.hitFlash > 0) this.hitFlash -= dt * 3;
                    return;
                }
                
                this.wanderTimer -= dt;
                this.aggroTimer -= dt;
                
                if (this.isFeared && this.fearSource) {
                    const angle = Math.atan2(this.y - this.fearSource.y, this.x - this.fearSource.x);
                    this.targetX = this.x + Math.cos(angle) * 200;
                    this.targetY = this.y + Math.sin(angle) * 200;
                } else {
                    if (player && !this.inCombat && !player.isInvisible) {
                        const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                        if (distToPlayer < 180 && this.tier >= player.tier - 1) {
                            this.aggroTarget = player;
                            this.aggroTimer = 2;
                        }
                    }

                    if (this.inCombat && this.combatTarget) {
                        const dist = Math.hypot(this.combatTarget.x - this.x, this.combatTarget.y - this.y);
                        if (dist > this.size + this.combatTarget.size + 20) {
                            this.targetX = this.combatTarget.x;
                            this.targetY = this.combatTarget.y;
                        }
                    } else if (this.aggroTarget && this.aggroTimer > 0) {
                        this.targetX = this.aggroTarget.x;
                        this.targetY = this.aggroTarget.y;
                    } else if (this.wanderTimer <= 0) {
                        this.aggroTarget = null;
                        let closestFood = null;
                        let minD = 250;
                        
                        for (let f of foods) {
                            const d = Math.hypot(f.x - this.x, f.y - this.y);
                            if (d < minD) { minD = d; closestFood = f; }
                        }

                        if (closestFood) {
                            this.targetX = closestFood.x;
                            this.targetY = closestFood.y;
                            this.wanderTimer = 1 + Math.random();
                        } else {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 100 + Math.random() * 200;
                            this.targetX = Math.max(50, Math.min(CANVAS_WIDTH - 50, this.x + Math.cos(angle) * dist));
                            this.targetY = Math.max(50, Math.min(CANVAS_HEIGHT - 50, this.y + Math.sin(angle) * dist));
                            this.wanderTimer = 2 + Math.random() * 3;
                        }
                    }
                }

                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 10) {
                    const targetAngle = Math.atan2(dy, dx);
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.angle += angleDiff * dt * 5;
                    
                    this.vx = Math.cos(this.angle);
                    this.vy = Math.sin(this.angle);
                } else {
                    this.vx = 0; this.vy = 0;
                }

                super.update(dt);
                
                // Emit bot movement to server (only for local bots, not remote ones)
                if (!this.isRemote && socket && isConnected) {
                    // Throttle updates - only send every few frames
                    if (!this.lastEmitTime || Date.now() - this.lastEmitTime > 100) {
                        this.lastEmitTime = Date.now();
                        socket.emit('botMoved', {
                            botId: this.botId,
                            x: this.x,
                            y: this.y,
                            angle: this.angle
                        });
                    }
                }
            }

            die() {
                this.isDead = true;
                this.respawnTimer = 5; // Respawn after 5 seconds
                
                // Notify server of bot death (only for local bots)
                if (!this.isRemote && socket && isConnected) {
                    socket.emit('botDied', { botId: this.botId });
                }
            }

            respawn() {
                this.isDead = false;
                this.x = Math.random() * CANVAS_WIDTH;
                this.y = Math.random() * CANVAS_HEIGHT;
                this.tier = 1;
                this.animalIndex = Math.floor(Math.random() * 3);
                this.animalData = TIER_ANIMALS[1][this.animalIndex];
                this.updateStats();
                this.hp = this.maxHp;
                this.xp = 0;
                this.clearPowerups();
                
                // Notify server of bot respawn (only for local bots)
                if (!this.isRemote && socket && isConnected) {
                    socket.emit('botRespawned', {
                        botId: this.botId,
                        x: this.x,
                        y: this.y,
                        hp: this.hp,
                        tier: this.tier,
                        animalIndex: this.animalIndex
                    });
                }
            }
        }

        class Food {
            constructor() {
                this.x = Math.random() * CANVAS_WIDTH;
                this.y = Math.random() * CANVAS_HEIGHT;
                this.size = 5 + Math.random() * 5;
                this.xp = Math.floor(this.size * 2);
                this.healAmount = Math.floor(this.size * 1.5);
                this.hue = Math.random() * 360;
                this.floatOffset = Math.random() * 100;
            }
            draw(ox, oy) {
                const yOff = Math.sin((Date.now() / 500) + this.floatOffset) * 3;
                const sx = this.x - ox;
                const sy = this.y - oy + yOff;
                
                ctx.fillStyle = 'hsl(' + this.hue + ', 80%, 60%)';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'hsl(' + this.hue + ', 80%, 60%)';
                ctx.beginPath();
                ctx.arc(sx, sy, this.size, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.beginPath();
                ctx.arc(sx - this.size*0.3, sy - this.size*0.3, this.size*0.25, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function sendChatMessage(message) {
    if (!player) return;
    const fullMessage = player.name + ' ' + message;
    chatMessages.push({ text: fullMessage, time: Date.now() });
    if (chatMessages.length > 5) chatMessages.shift();
    updateChatDisplay();
    
    // Broadcast to other players - send just the message text, not full message
    if (socket && isConnected) {
        socket.emit('chatMessage', {
            text: message, // Send just the message, server adds name
            playerName: player.name
        });
    }
}

        function updateChatDisplay() {
            const chatContainer = document.getElementById('chat-messages');
            chatContainer.innerHTML = '';
            chatMessages.forEach(msg => {
                const div = document.createElement('div');
                div.className = 'chat-message';
                const parts = msg.text.split(' ');
                div.innerHTML = '<span class="sender">' + parts[0] + '</span> ' + parts.slice(1).join(' ');
                chatContainer.appendChild(div);
            });
        }

       function showEvolutionBar(tier) {
            const evolutionBar = document.getElementById('evolution-bar');
            const optionsContainer = document.getElementById('evolution-options');
            optionsContainer.innerHTML = '';
            
            const tierAnimals = TIER_ANIMALS[tier];
            tierAnimals.forEach((animal, index) => {
                const option = document.createElement('div');
                option.className = 'evolution-option';
                option.innerHTML = '<h4>' + animal.name + '</h4>' +
                                   '<p>HP: ' + animal.hp + ' | Dmg: ' + animal.damage + '</p>';
                option.onclick = () => evolveToAnimal(tier, index);
                optionsContainer.appendChild(option);
            });
            
            evolutionBar.style.display = 'block';
        }

        function hideEvolutionBar() {
            document.getElementById('evolution-bar').style.display = 'none';
            currentEvolutionTier = 0;
        }

        function evolveToAnimal(tier, animalIndex) {
            player.evolve(tier, animalIndex);
        }

        function prepareGame() {
            const name = document.getElementById('guest-name').value.trim();
            if (!name) {
                showToast('Please enter a nickname!', 'error');
                return;
            }
            playerName = name;
            
            // Connect to server now, before game starts
            connectToServer();
            
            document.getElementById('main-menu').style.display = 'none';
            showAnimalSelection();
        }

        function showAnimalSelection() {
            const grid = document.getElementById('animal-grid');
            grid.innerHTML = '';
            TIER_ANIMALS[1].forEach((animal, index) => {
                const card = document.createElement('div');
                card.className = 'animal-card';
                card.innerHTML = '<h3>' + animal.name + '</h3>' +
                                  '<div style="font-size:0.8rem; color:#555;">' +
                                    'HP: ' + animal.hp + '<br>' +
                                    'Speed: ' + animal.speed + '<br>' +
                                    'Dmg: ' + animal.damage +
                                  '</div>';
                card.onclick = () => startGame(index);
                grid.appendChild(card);
            });
            document.getElementById('animal-selection').style.display = 'flex';
        }

        function startGame(animalIndex) {
            document.getElementById('animal-selection').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'block';
            document.getElementById('boost-container').style.display = 'flex';
            document.getElementById('chat-container').style.display = 'block';
            document.getElementById('top-right-ui').style.display = 'none';
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            player = new Entity(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, playerName, animalIndex, false);
            
            foods = []; bots = {}; particles = []; statusEffects = []; damageTexts = []; xpOrbs = [];
            boostCharges = 0;
            chatMessages = [];
            
            for (let i=0; i<2000; i++) foods.push(new Food());
            
            // Spawn bots and notify server
            for (let i=0; i<20; i++) {
                const bot = new Bot(Math.random()*CANVAS_WIDTH, Math.random()*CANVAS_HEIGHT);
                bots[bot.botId] = bot;
                
                // Notify server about this bot spawn
                if (socket && isConnected) {
                    socket.emit('botSpawned', {
                        botId: bot.botId,
                        x: bot.x,
                        y: bot.y,
                        tier: bot.tier,
                        animalIndex: bot.animalIndex,
                        hp: bot.hp,
                        maxHp: bot.maxHp
                    });
                }
            }
            
            if (socket && isConnected) {
                socket.emit('playerJoin', {
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    name: player.name,
                    userId: currentUser ? currentUser.id : null, // ADD THIS LINE
                    color: player.color,
                    size: player.size,
                    tier: player.tier,
                    hp: player.hp,
                    xp: player.xp,
                    animalType: player.animalData.name,
                    animalIndex: player.animalIndex
                });
            }
            gameRunning = true;
            lastUpdateTime = Date.now();
            requestAnimationFrame(gameLoop);
        }
// FORUM SYSTEM
        let selectedCategory = null;
        let lastPostTime = 0;
        const POST_COOLDOWN = 10 * 1000; // 10 seconds in milliseconds

        async function openForum() {
            document.getElementById('forum-modal').style.display = 'flex';
            await loadForumPosts();
            updateCooldownDisplay();
            
            // Show login message if not logged in
            if (!currentUser) {
                showToast('Login to create posts!', 'error');
            }
        }

        function closeForum() {
            document.getElementById('forum-modal').style.display = 'none';
        }

        function selectCategory(category) {
            selectedCategory = category;
            
            // Update UI
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector(`[data-category="${category}"]`).classList.add('selected');
        }

        async function createForumPost() {
    // Check if logged in first
    if (!currentUser) {
        showToast('You must be logged in to post!', 'error');
        closeForum();
        openAuthModal();
        return;
    }
            
            const title = document.getElementById('forum-title').value.trim();
            const description = document.getElementById('forum-description').value.trim();
            
            // Validation
            if (!selectedCategory) {
                showToast('Please select a category!', 'error');
                return;
            }
            
            if (!title) {
                showToast('Please enter a title!', 'error');
                return;
            }
            
            if (!description) {
                showToast('Please enter a description!', 'error');
                return;
            }
            
            // Check cooldown
            const now = Date.now();
            const timeSinceLastPost = now - lastPostTime;
            
            if (timeSinceLastPost < POST_COOLDOWN && lastPostTime !== 0) {
                const remainingSeconds = Math.ceil((POST_COOLDOWN - timeSinceLastPost) / 1000);
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                showToast(`Please wait ${minutes}m ${seconds}s before posting again`, 'error');
                return;
            }
            
            // Get username from logged in user
            const author = currentUser.user_metadata?.username || currentUser.email.split('@')[0];
            
            // Create post object
            const post = {
                id: 'post_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                category: selectedCategory,
                title: title,
                description: description,
                author: author,
                timestamp: now
            };
            
            // Save to storage
// Save to Supabase
try {
    console.log('Attempting to create forum post:', post);
    
    const { data, error } = await supabase
        .from('forum_posts')
        .insert([{
            category: post.category,
            title: post.title,
            description: post.description,
            author: post.author,
            created_at: new Date().toISOString()
        }]);
    
    if (error) throw error;
    
    // Success!
    showToast('Post created successfully!', 'success');
    lastPostTime = now;
    
    // Clear form
    document.getElementById('forum-title').value = '';
    document.getElementById('forum-description').value = '';
    selectedCategory = null;
    document.querySelectorAll('.category-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    
    // Reload posts
    await loadForumPosts();
    updateCooldownDisplay();
} catch (error) {
    console.error('Error creating post:', error);
    showToast(`Error: ${error.message || 'Unknown error'}`, 'error');
}
        }

        async function loadForumPosts() {
    try {
        const { data: posts, error } = await supabase
            .from('forum_posts')
            .select('*')
            .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        displayForumPosts(posts || []);
    } catch (error) {
        console.error('Error loading posts:', error);
    }
    function displayForumPosts(posts) {
            const container = document.getElementById('forum-posts-list');
            if (!container) return;
            
            if (posts.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: rgba(0,0,0,0.5);">No posts yet. Be the first to post!</div>';
                return;
            }
            
            container.innerHTML = '';
            
            posts.forEach(post => {
                const postCard = document.createElement('div');
                postCard.className = 'forum-post-card';
                postCard.style.cssText = `
                    background: white;
                    border-radius: 15px;
                    padding: 20px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: transform 0.2s;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                `;
                
                postCard.onmouseover = () => postCard.style.transform = 'translateY(-3px)';
                postCard.onmouseout = () => postCard.style.transform = 'translateY(0)';
                
                const categoryColors = {
                    'General': '#3498db',
                    'Strategy': '#e74c3c',
                    'Feedback': '#2ecc71',
                    'Bug Report': '#f39c12'
                };
                
                const timeAgo = getTimeAgoFromISO(post.created_at);
                
                postCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                        <span style="background: ${categoryColors[post.category] || '#95a5a6'}; color: white; padding: 5px 12px; border-radius: 20px; font-size: 0.8rem; font-weight: bold;">
                            ${post.category}
                        </span>
                        <span style="color: #7f8c8d; font-size: 0.9rem;">${timeAgo}</span>
                    </div>
                    <h3 style="margin: 10px 0; color: #2c3e50; font-size: 1.3rem;">${post.title}</h3>
                    <p style="color: #7f8c8d; margin: 10px 0; line-height: 1.5;">${post.description.substring(0, 150)}${post.description.length > 150 ? '...' : ''}</p>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ecf0f1;">
                        <span style="color: #3498db; font-weight: bold;">ðŸ‘¤ ${post.author}</span>
                        <span style="color: #95a5a6; font-size: 0.9rem;">Click to view & comment</span>
                    </div>
                `;
                
                postCard.onclick = () => viewPost(post);
                container.appendChild(postCard);
            });
        }
        
        function getTimeAgoFromISO(isoString) {
            const postDate = new Date(isoString);
            const now = new Date();
            const diff = now - postDate;
            
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return days + ' day' + (days > 1 ? 's' : '') + ' ago';
            if (hours > 0) return hours + ' hour' + (hours > 1 ? 's' : '') + ' ago';
            if (minutes > 0) return minutes + ' minute' + (minutes > 1 ? 's' : '') + ' ago';
            return 'just now';
        }
        
        async function viewPost(post) {
            const modal = document.createElement('div');
            modal.id = 'post-view-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 20px;
                padding: 30px;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            const { data: comments } = await supabase
                .from('forum_comments')
                .select('*')
                .eq('post_id', post.id)
                .order('created_at', { ascending: true });
            
            const categoryColors = {
                'General': '#3498db',
                'Strategy': '#e74c3c',
                'Feedback': '#2ecc71',
                'Bug Report': '#f39c12'
            };
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <span style="background: ${categoryColors[post.category] || '#95a5a6'}; color: white; padding: 8px 15px; border-radius: 20px; font-weight: bold;">
                        ${post.category}
                    </span>
                    <button id="close-post-view" style="background: none; border: none; font-size: 2rem; cursor: pointer; color: #7f8c8d;">Ã—</button>
                </div>
                
                <h2 style="color: #2c3e50; margin-bottom: 10px;">${post.title}</h2>
                <p style="color: #7f8c8d; margin-bottom: 20px;">By <strong>${post.author}</strong> â€¢ ${getTimeAgoFromISO(post.created_at)}</p>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 30px;">
                    <p style="color: #2c3e50; line-height: 1.6; white-space: pre-wrap;">${post.description}</p>
                </div>
                
                <h3 style="color: #2c3e50; margin-bottom: 15px;">ðŸ’¬ Comments (${comments ? comments.length : 0})</h3>
                
                <div id="comments-list" style="margin-bottom: 20px;">
                    ${comments && comments.length > 0 ? 
                        comments.map(c => `
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <strong style="color: #3498db;">${c.author}</strong>
                                    <span style="color: #7f8c8d; font-size: 0.9rem;">${getTimeAgoFromISO(c.created_at)}</span>
                                </div>
                                <p style="color: #2c3e50; line-height: 1.5;">${c.comment}</p>
                            </div>
                        `).join('') 
                        : '<p style="color: #7f8c8d; text-align: center; padding: 20px;">No comments yet. Be the first to comment!</p>'
                    }
                </div>
                
                ${currentUser ? `
                    <div style="margin-top: 20px;">
                        <textarea id="comment-input" placeholder="Write a comment..." style="
                            width: 100%;
                            min-height: 80px;
                            padding: 12px;
                            border: 2px solid #e0e0e0;
                            border-radius: 10px;
                            font-family: 'Nunito', sans-serif;
                            resize: vertical;
                            margin-bottom: 10px;
                        "></textarea>
                        <button id="post-comment-btn" style="
                            background: linear-gradient(45deg, #4facfe, #00f2fe);
                            color: white;
                            border: none;
                            padding: 12px 25px;
                            border-radius: 10px;
                            font-weight: bold;
                            cursor: pointer;
                            width: 100%;
                        ">Post Comment</button>
                    </div>
                ` : `
                    <p style="text-align: center; color: #7f8c8d; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                        <strong>Login to comment on this post</strong>
                    </p>
                `}
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            document.getElementById('close-post-view').onclick = () => {
                document.body.removeChild(modal);
            };
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
            
            if (currentUser) {
                document.getElementById('post-comment-btn').onclick = async () => {
                    const commentText = document.getElementById('comment-input').value.trim();
                    if (!commentText) {
                        showToast('Please write a comment!', 'error');
                        return;
                    }
                    
                    try {
                        const author = currentUser.user_metadata?.username || currentUser.email.split('@')[0];
                        
                        const { error } = await supabase
                            .from('forum_comments')
                            .insert([{
                                post_id: post.id,
                                author: author,
                                comment: commentText
                            }]);
                        
                        if (error) throw error;
                        
                        showToast('Comment posted!', 'success');
                        document.body.removeChild(modal);
                        viewPost(post);
                    } catch (error) {
                        console.error('Error posting comment:', error);
                        showToast('Error posting comment', 'error');
                    }
                };
            }
        }
}

        function updateCooldownDisplay() {
            const now = Date.now();
            const timeSinceLastPost = now - lastPostTime;
            const cooldownDiv = document.getElementById('forum-cooldown');
            const createBtn = document.getElementById('create-post-btn');
            
            if (timeSinceLastPost < POST_COOLDOWN && lastPostTime !== 0) {
                const remainingMs = POST_COOLDOWN - timeSinceLastPost;
                const minutes = Math.floor(remainingMs / 60000);
                const seconds = Math.floor((remainingMs % 60000) / 1000);
                
                cooldownDiv.style.display = 'block';
                cooldownDiv.textContent = `Cooldown: ${minutes}m ${seconds}s remaining`;
                createBtn.disabled = true;
                
                // Update every second
                setTimeout(updateCooldownDisplay, 1000);
            } else {
                cooldownDiv.style.display = 'none';
                createBtn.disabled = false;
            }
        }

        function getTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return days + ' day' + (days > 1 ? 's' : '') + ' ago';
            if (hours > 0) return hours + ' hour' + (hours > 1 ? 's' : '') + ' ago';
            if (minutes > 0) return minutes + ' minute' + (minutes > 1 ? 's' : '') + ' ago';
            return 'Just now';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        function gameLoop() {
            if (!gameRunning) return;
            const now = Date.now();
            const dt = Math.min((now - lastUpdateTime) / 1000, 0.1);
            lastUpdateTime = now;

            if (dashCooldown > 0) dashCooldown -= dt;

            if (!player.isStunned && !player.isFeared) {
                const dx = mouseX + camera.x - player.x;
                const dy = mouseY + camera.y - player.y;
                const targetAngle = Math.atan2(dy, dx);
                
                let angleDiff = targetAngle - player.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                player.angle += angleDiff * dt * 8;
                
                const dist = Math.hypot(dx, dy);
                
                if (dist > 20) {
                    player.vx = Math.cos(player.angle);
                    player.vy = Math.sin(player.angle);
                } else {
                    player.vx *= 0.9;
                    player.vy *= 0.9;
                }
            }
            player.update(dt);

            Object.values(bots).forEach(b => {
                if (!b.isDead) b.update(dt);
            });
            
            statusEffects = statusEffects.filter(se => se.update(dt));
            
            for (let i = foods.length - 1; i >= 0; i--) {
                const f = foods[i];
                if (Math.hypot(f.x - player.x, f.y - player.y) < player.size + f.size) {
                    player.xp += f.xp;
                    // Send XP update every 10 food
if (Math.floor(player.xp) % 10 === 0 && socket && isConnected) {
    socket.emit('playerUpdate', {
        size: player.size,
        tier: player.tier,
        hp: player.hp,
        xp: player.xp,
        color: player.color,
        animalType: player.animalData.name,
        animalIndex: player.animalIndex
    });
}
                    player.heal(f.healAmount);
                    
                    if (boostCharges < 3) {
                        boostCharges++;
                    }
                    
                    foods.splice(i, 1);
                    foods.push(new Food());
                }
            }

            Object.values(bots).forEach(b => {
                if (b.isDead) return;
                for (let i = foods.length - 1; i >= 0; i--) {
                    const f = foods[i];
                    if (Math.hypot(f.x - b.x, f.y - b.y) < b.size + f.size) {
                        b.xp += f.xp;
                        b.heal(f.healAmount);
                        foods.splice(i, 1);
                        foods.push(new Food());
                    }
                }
            });

            for (let i = xpOrbs.length - 1; i >= 0; i--) {
                const orb = xpOrbs[i];
                orb.update(dt);
                if (Math.hypot(orb.x - player.x, orb.y - player.y) < player.size + orb.size) {
                    player.xp += orb.amount;
                    xpOrbs.splice(i, 1);
                } else if (orb.life <= 0) {
                    xpOrbs.splice(i, 1);
                }
            }
// PLAYER VS PLAYER COMBAT (with 2-second cooldown, only during dash)
            Object.values(otherPlayers).forEach(other => {
                if (!other || other.isDead) return;
                if (player.isStunned || other.isStunned) return;
                
                const dist = Math.hypot(other.x - player.x, other.y - player.y);
                const minDist = player.size + other.size;
                
                if (dist < minDist) {
                    const now = Date.now();
                    
                    // Only deal damage when actively dashing
                    if (player.isDashing && player.size >= other.size) {
                        // Cooldown - only damage once per 2 seconds
                        if (!player.lastPvpHitTime) player.lastPvpHitTime = {};
                        if (player.lastPvpHitTime[other.id] && now - player.lastPvpHitTime[other.id] < 2000) {
                            return; // Skip if hit this player recently
                        }
                        
                        // Player is bigger AND dashing - deal damage
                        const damage = Math.max(10, player.tier * 5);
                        player.lastPvpHitTime[other.id] = now;
                        
                        // Visual feedback on OTHER player
                        damageTexts.push(new DamageText(other.x, other.y - other.size - 20, damage, '#e74c3c'));
                        for (let i = 0; i < 5; i++) {
                            particles.push(new Particle(other.x, other.y, other.color, 'hit'));
                        }
                        
                        // Tell server about hit
                        if (socket && isConnected) {
                            socket.emit('playerHit', {
                                targetId: other.id,
                                damage: damage
                            });
                        }
                        
                        player.inCombat = true;
                        player.lastHitTime = Date.now();
                    }
                    
                    // Push players apart slightly to prevent sticking
                    const pushAngle = Math.atan2(player.y - other.y, player.x - other.x);
                    const pushForce = 3;
                    player.x += Math.cos(pushAngle) * pushForce;
                    player.y += Math.sin(pushAngle) * pushForce;
                }
            });

            Object.values(bots).forEach(b => {
                if (b.hp <= 0 && !b.isDead) {
                    const stolenXp = Math.floor(b.xp);
                    player.xp += stolenXp;
                    
                    const orbCount = 3 + Math.floor(b.tier * 2);
                    const xpPerOrb = Math.floor((20 + b.tier * 15) / orbCount);
                    for (let i = 0; i < orbCount; i++) {
                        xpOrbs.push(new XpOrb(b.x, b.y, xpPerOrb));
                    }
                    
                    if (stolenXp > 0) {
                        damageTexts.push(new DamageText(b.x, b.y - b.size - 50, -stolenXp, '#f1c40f'));
                    }
                    
                    for (let k = 0; k < 15; k++) {
                        particles.push(new Particle(b.x, b.y, b.color, 'hit'));
                    }
                    
                    b.die();
                }
            });
            
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
            
            damageTexts.forEach(d => d.update(dt));
            damageTexts = damageTexts.filter(d => d.life > 0);

            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            camera.x = Math.max(0, Math.min(CANVAS_WIDTH - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(CANVAS_HEIGHT - canvas.height, camera.y));

            drawGame();
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        function drawGame() {
            const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
            g.addColorStop(0, '#4facfe'); g.addColorStop(1, '#00f2fe');
            ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 2;
            const gs = 100;
            const ox = -camera.x % gs;
            const oy = -camera.y % gs;
            ctx.beginPath();
            for (let x = ox; x < canvas.width; x += gs) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = oy; y < canvas.height; y += gs) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();

            foods.forEach(f => f.draw(camera.x, camera.y));
            xpOrbs.forEach(o => o.draw(camera.x, camera.y));
            particles.forEach(p => p.draw(camera.x, camera.y));
            Object.values(bots).forEach(b => { if (!b.isDead) b.draw(camera.x, camera.y); });
            if (player) player.draw(camera.x, camera.y, true);
            // Draw other players using their Entity.draw() method
            Object.values(otherPlayers).forEach(p => {
                if (p && !p.isDead) {
                    p.draw(camera.x, camera.y, false);
                }
            });
            damageTexts.forEach(d => d.draw(camera.x, camera.y));
        }

        function updateUI() {
            for (let i = 1; i <= 3; i++) {
                const bar = document.getElementById('boost-bar-' + i);
                const fill = bar.querySelector('.boost-bar-fill');
                if (boostCharges >= i) {
                    fill.style.width = '100%';
                    bar.classList.add('full');
                } else {
                    fill.style.width = '0%';
                    bar.classList.remove('full');
                }
            }
            
            const abilityDisplay = document.getElementById('ability-display');
            if (player && player.animalData.ability) {
                const abilityInfo = ABILITIES[player.animalData.ability];
                abilityDisplay.style.display = 'block';
                if (player.abilityCooldown > 0) {
                    abilityDisplay.textContent = abilityInfo.name + ' (' + Math.ceil(player.abilityCooldown) + 's)';
                    abilityDisplay.style.opacity = '0.5';
                } else {
                    abilityDisplay.textContent = abilityInfo.name + ' Ready [E]';
                    abilityDisplay.style.opacity = '1';
                }
            } else {
                abilityDisplay.style.display = 'none';
            }
            
            const list = document.getElementById('leaderboard-list');
            if (player) {
                // Create leaderboard with all players
                const allPlayers = [
                    { name: player.name, xp: player.xp, tier: player.tier, isSelf: true }
                ];
                
                // Add other players
                Object.values(otherPlayers).forEach(p => {
                    allPlayers.push({ name: p.name, xp: p.xp || 0, tier: p.tier || 1, isSelf: false });
                });
                
                // Sort by XP
                allPlayers.sort((a, b) => b.xp - a.xp);
                
                // Build HTML
                let html = '';
                allPlayers.slice(0, 5).forEach((p, i) => {
                    const className = p.isSelf ? 'leaderboard-entry self' : 'leaderboard-entry';
                    html += '<div class="' + className + '">' +
                            '<span>' + (i + 1) + '. ' + p.name + '</span>' +
                            '<span>' + Math.floor(p.xp) + ' XP</span>' +
                            '</div>';
                });
                
                list.innerHTML = html;
            }
        }

        function playerDied() {
            gameRunning = false;
            if (socket && isConnected) {
                socket.emit('playerDied');
            }
            finalStats.tier = player.tier;
            finalStats.xp = Math.floor(player.xp);
            finalStats.animal = player.animalData.name;
            
            document.getElementById('death-stats').textContent = 
                'You reached Tier ' + finalStats.tier + ' as a ' + finalStats.animal + ' with ' + finalStats.xp + ' XP';
            document.getElementById('death-screen').style.display = 'flex';
        }

        function returnToMenu() {
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none';
            document.getElementById('boost-container').style.display = 'none';
            document.getElementById('ability-display').style.display = 'none';
            document.getElementById('chat-container').style.display = 'none';
            document.getElementById('evolution-bar').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('top-left-ui').style.display = 'flex';
            document.getElementById('top-right-ui').style.display = 'block';
            
            player = null;
            bots = {};
            foods = [];
            particles = [];
            damageTexts = [];
            xpOrbs = [];
            statusEffects = [];
            chatMessages = [];
            boostCharges = 0;
            gameRunning = false;
            chatOpen = false;
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#",""),16),
            amt = Math.round(2.55 * percent),
            R = Math.min(255, (num >> 16) + amt),
            G = Math.min(255, ((num >> 8) & 0x00FF) + amt),
            B = Math.min(255, (num & 0x0000FF) + amt);
            return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#",""),16),
            amt = Math.round(2.55 * percent),
            R = Math.max(0, (num >> 16) - amt),
            G = Math.max(0, ((num >> 8) & 0x00FF) - amt),
            B = Math.max(0, (num & 0x0000FF) - amt);
            return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
        }

        function showToast(msg, type) {
            const t = document.getElementById('toast');
            t.className = 'show ' + type;
            t.innerText = msg;
            setTimeout(() => t.className = '', 3000);
        }

        window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
        window.addEventListener('mousedown', () => {
            if (player && gameRunning && !chatOpen) {
                player.dash();
            }
        });
        window.addEventListener('keydown', e => {
            if (e.code === 'Enter') {
                e.preventDefault();
                if (!gameRunning) return;
                
                if (!chatOpen) {
                    chatOpen = true;
                    document.getElementById('chat-input-container').style.display = 'block';
                    document.getElementById('chat-input').focus();
                } else {
                    const input = document.getElementById('chat-input');
                    const message = input.value.trim();
                    if (message) {
                        sendChatMessage('says: ' + message);
                    }
                    input.value = '';
                    chatOpen = false;
                    document.getElementById('chat-input-container').style.display = 'none';
                }
            }
            
            if (chatOpen) return; // Don't allow game controls while chatting
            
            if (e.code === 'Space' && player && gameRunning) {
                e.preventDefault();
                player.dash();
            }
            if (e.code === 'KeyE' && player && gameRunning) {
                player.useAbility();
            }
        });
        window.addEventListener('resize', () => { 
            if(canvas) { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        });
    </script>
</body>
</html>
